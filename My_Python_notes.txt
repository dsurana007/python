Python is a general-purpose interpreted, interactive, object-oriented and high-level programming language. Python was created by Guido van Rossum in the late eighties and early nineties. Like Perl, Python source code is also now available under the GNU General Public License (GPL).

What is Mean by Python is interpreted?

What�s the difference between a compiled and interpreted language?
Interpretation and compilation are properties of the implementation of a language

It�s not accurate to say that a language is interpreted or compiled because interpretation and compilation are both properties of the implementation of that particular language, and not a property of the language itself. So, in theory, any language can be compiled or interpreted � it just depends on what the particular implementation that you are using does.
What exactly is compilation?

In a compiled implementation of a language, a compiler will translate the program directly into code that is specific to the target machine, which is also known as machine code � basically code that is specific to a given processor and operating system. Then the computer will run the machine code on its own.
What exactly is interpretation?

In an interpreted implementation of a language, the source code is not directly run by the target machine. What happens instead is that another program reads and then executes the original source code. This other program is also known as the interpreter. The interpreter is usually written specifically for the native machine. As an example, you could consider the multiplier operation � the �*�. If the interpreter sees this in your code, then at run time it would call its own definition of the multiplier function � maybe something called �multiply(x,y)�. And then that �multiply(x,y)� would execute the machine code�s equivalent of the multiply instruction.

In interpretation, the original source code is also typically converted into some intermediate code which is then processed by an interpreter that converts the intermediate code into machine specific code.
Are interpreters and compilers mutually exclusive?

No, they are not mutually exclusive � because there are some interpreters which also do some translation work, just like compilers normally do. So, the work that a compiler typically does can also be done by an interpreter.
Can a compiled implementation of a language do the same things as an interpreted implementation of a language?

Yes, you can accomplish exactly the same things with both interpreted and compiled languages. But, in general terms there are advantages and disadvantages of both compiled and interpreted languages.
So, what are the advantages and disadvantages of compilation and interpretation?

Because comparing compilation and interpretation is so dependent on the specific implementation of the interpreter and compiler, we can only compare compilation and interpretation in very general terms � there will be exceptions to what we say below, but in general these things are true:

    Compiled implementations of languages have the advantage of being faster because they translate directly to the native code of the specific machine.
    Interpreted implementations of languages tend to be more portable as well.
    Interpreted implementations of languages are generally easier to create because writing compilers is difficult.

Is Java interpreted or compiled?

Interestingly enough, some implementations of Java are implemented as both interpreted and compiled � all at once. This is actually dependent on the JVM � Java is usually compiled down to the byte code by the Java compiler. But whether the JVM interprets or compiles that byte code is dependent on which JVM is being used. The difference between a JVM that compiles the byte code and a JVM that interprets the byte code is that an interpreting JVM will both translate the byte code and execute it at the same time as well, but with a JVM compiler the translation only occurs once, because an executable file is created in compilation. And that is the key difference between the two � although nowadays with just in time compilation the distinction is becoming a bit blurred.
What is the benefit of having Java be both interpreted and compiled?

When Java code is compiled from a .java file to a .class file, that .class file is what�s known as Java bytecode. Java is hardware/machine independent, which means that any machine can run Java bytecode provided it has a JVM specifically built for that machine. The bytecode is then interpreted (some JVM�s will compile the bytecode) by the given virtual machine. This means that the details of making the code work on a specific hardware platform are handled by the virtual machine.

Java is compiled to bytecode first because it allows the virtual machine to be more efficient because it only has to recognize bytecode. This is more efficient than just having the virtual machine interpret the original source code at run time. 



Python Features:

Python's feature highlights include:

    Easy-to-learn: Python has relatively few keywords, simple structure, and a clearly defined syntax. This allows the student to pick up the language in a relatively short period of time.

    Easy-to-read: Python code is much more clearly defined and visible to the eyes.

    Easy-to-maintain: Python's success is that its source code is fairly easy-to-maintain.

    A broad standard library: One of Python's greatest strengths is the bulk of the library is very portable and cross-platform compatible on UNIX, Windows and Macintosh.

    Interactive Mode: Support for an interactive mode in which you can enter results from a terminal right to the language, allowing interactive testing and debugging of snippets of code.

    Portable: Python can run on a wide variety of hardware platforms and has the same interface on all platforms.
Due to its open-source nature, Python has been ported to (i.e. changed to make
it work on) many platforms. All your Python programs can work on any of these
platforms without requiring any changes at all if you are careful enough to avoid
any system-dependent features.
You can use Python on Linux, Windows, FreeBSD, Macintosh, Solaris, OS/2,
Amiga, AROS, AS/400, BeOS, OS/390, z/OS, Palm OS, QNX, VMS, Psion,
Acorn RISC OS, VxWorks, PlayStation, Sharp Zaurus, Windows CE and even
PocketPC!

    Extendable: You can add low-level modules to the Python interpreter. These modules enable programmers to add to or customize their tools to be more efficient.

    Databases: Python provides interfaces to all major commercial databases.

    GUI Programming: Python supports GUI applications that can be created and ported to many system calls, libraries and windows systems, such as Windows MFC, Macintosh and the X Window system of Unix.

    Scalable: Python provides a better structure and support for large programs than shell scripting.

1. Install python 2.5 edit path variable as C:\Python25
2. Go to start menu python2.5 go to IDE you can use GUI mode for proramming.
3. print staement ex. print "Hello world!!"
Should I use Python 2 or Python 3 for my development activity?
Short version: Python 2.x is legacy, Python 3.x is the present and future of the language 
Python 3.0 was released in 2008. The final 2.x version 2.7 release came out in mid-2010, with a statement of extended support for this end-of-life release. The 2.x branch will see no new major releases after that. 3.x is under active development and has already seen over five years of stable releases, including version 3.3 in 2012 and 3.4 in 2014. This means that all recent standard library improvements, for example, are only available by default in Python 3.x. 
Guido van Rossum (the original creator of the Python language) decided to clean up Python 2.x properly, with less regard for backwards compatibility than is the case for new releases in the 2.x range. The most drastic improvement is the better Unicode support (with all text strings being Unicode by default) as well as saner bytes/Unicode separation. 

What is Unicode?

Fundamentally, computers just deal with numbers. They store letters and other characters by assigning a number for each one. Before Unicode was invented, there were hundreds of different encoding systems for assigning these numbers. No single encoding could contain enough characters: for example, the European Union alone requires several different encodings to cover all its languages. Even for a single language like English no single encoding was adequate for all the letters, punctuation, and technical symbols in common use.
These encoding systems also conflict with one another. That is, two encodings can use the same number for two different characters, or use different numbers for the same character. Any given computer (especially servers) needs to support many different encodings; yet whenever data is passed between different encodings or platforms, that data always runs the risk of corruption.


What�s New In Python 3.0
The print statement has been replaced with a print() function, with keyword arguments to replace most of the special syntax of the old print statemen
Old: print "The answer is", 2*2
New: print("The answer is", 2*2)

Old: print x,           # Trailing comma suppresses newline
New: print(x, end=" ")  # Appends a space instead of a newline

Old: print              # Prints a newline
New: print()            # You must call the function!

Old: print >>sys.stderr, "fatal error"
New: print("fatal error", file=sys.stderr)

Old: print (x, y)       # prints repr((x, y))
New: print((x, y))      # Not the same as print(x, y)!






Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.

Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals or characters in these variables.

Python variables do not have to be explicitly declared to reserve memory space. The declaration happens automatically when you assign a value to a variable. The equal sign (=) is used to assign values to variables



Python supports four different numerical types:

    int (signed integers): often called just integers or ints, are positive or negative whole numbers with no decimal point.

    long (long integers ): or longs, are integers of unlimited size, written like integers and followed by an uppercase or lowercase L.

    float (floating point real values) : or floats, represent real numbers and are written with a decimal point dividing the integer and fractional parts. Floats may also be in scientific notation, with E or e indicating the power of 10 (2.5e2 = 2.5 x 102 = 250).

    complex (complex numbers) : are of the form a + bJ, where a and b are floats and J (or j) represents the square root of -1 (which is an imaginary number). a is the real part of the number, and b is the imaginary part. Complex numbers are not used much in Python programming.



4. direct calculation on IDE like 2+2 it will give 4 same like 6/2=3 but 8/3=2 so if you want in decimal give 8.0/3=2.something or like 8/3.0=2.something

>>> (50 - 5*6) / 4
5.0
>>> 8 / 5  # division always returns a floating point number
1.6

>>> 17 / 3  # classic division returns a float
5.666666666666667
>>>
>>> 17 // 3  # floor division discards the fractional part
5

If you don�t want characters prefaced by \ to be interpreted as special characters, you can use raw strings by adding an r before the first quote:

>>>
>>> print('C:\some\name')  # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name')  # note the r before the quote
C:\some\name

Strings can be concatenated (glued together) with the + operator, and repeated with *:

>>>
>>> # 3 times 'un', followed by 'ium'
>>> 3 * 'un' + 'ium'
'unununium'

This only works with two literals though, not with variables or expressions:

>>>
>>> prefix = 'Py'
>>> prefix 'thon'  # can't concatenate a variable and a string literal
  ...
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  ...
SyntaxError: invalid syntax
Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically concatenated.

>>>
>>> 'Py' 'thon'
'Python'

This only works with two literals though, not with variables or expressions:

>>>
>>> prefix = 'Py'
>>> prefix 'thon'  # can't concatenate a variable and a string literal
  ...
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
  ...
SyntaxError: invalid syntax

5. For exponent like you can do suppose 6 power 3 then simply you can do 6*6*6 another way you can do like 6**3 same for other power like 5**4=5*5*5*5 
6. Declare a variable: simply do like x=18 now you can use x anywhere. user can ask to enter the value like : g= input("Enter number here: "). 
7. Functions and module:
	there are multiple inbuilt functions like pow(6,3)=216
	now we will use function floor(18.7) which will give you round fegiure value = 18.0 so if you directly used it like floor(18.7) it will give you an error like:
	Traceback (most recent call last):
  	File "<pyshell#0>", line 1, in <module>
    	floor(18.7)
	NameError: name 'floor' is not defined
	
	we r getting this error bcos floor function is not inbuilt so we have to import the extra module in which it is present so,
	import math
	now use like : math.floor(18.7)=18.0
	
	one more thing you can assing function to a variable like : bucky = math.sqrt and you can use it like bucky(9)=3
	
8. Save your program to a file: In Python IDE click on new window -> write down your code -> save with file extention .py

9. String: you can declare string using "kaley cocco" or like 'kaley cocco'
		
	   for strings like: he's a jurk  u have to use "he's a jurk"
	   For strings like : "bucky said ,"hey now" to me" so it will consider only "bucky said ," and "to me " seprate so to avoide this use:
			      "bucky said ,\"hey now\" to me" so it will ignore escape charatecter
				
	you can store strings in variables like x="bucky" y="ksdiehf"
	so to join string x+y
	you cant add string and number like :num=18 print ("hi...") + num it will give u an error. so do one thing : num= str(18) now print ("hi...") + num
	or you can use like this: print ("hi...") + `num`  "`" this sign is below tidle on keybord
	
10. Difference betweeen raw_input and input:

"input" takes the input as expression so it is better to use input when we use numbers.
"raw_input" takes input and converts it into string so while using strings use raw_input
he difference is that raw_input() does not exist in Python 3.x, while input() does. Actually, the old raw_input() has been renamed to input(), and the old input() is gone (but can easily be simulated by using eval(input())).

11.Sequence and Lists:

u can create a list by using following syntax:

family = ['dad','mom','bro','sys','dog']
once u define this automatic indexing is assigned to the elements like:

family[0]=dad
family[3]=sys

one more thing automatically negative indexing is assiged from -1 if u access it by back list:

family[-1]=dog
family[-3]=bro

In python Strings are also got sequenced :



11.Functions in Python:

Python has functions like most other languages, but it does not have separate header files like C++ or
interface/implementation sections like Pascal. When you need a function, just declare it, like this:

def buildConnectionString(params):

Note that the keyword def starts the function declaration, followed by the function name, followed by the arguments
in parentheses. Multiple arguments (not shown here) are separated with commas.
Also note that the function doesn't define a return datatype. Python functions do not specify the datatype of their
return value; they don't even specify whether or not they return a value. In fact, every Python function returns a value;
if the function ever executes a return statement, it will return that value, otherwise it will return None, the Python
null value.
In Visual Basic, functions (that return a value) start with function, and subroutines (that do not return a value)
start with sub. There are no subroutines in Python. Everything is a function, all functions return a value (even if it's
None), and all functions start with def.
The argument, params, doesn't specify a datatype. In Python, variables are never explicitly typed. Python figures out
what type a variable is and keeps track of it internally.
In Java, C++, and other statically-typed languages, you must specify the datatype of the function return value and
each function argument. In Python, you never explicitly specify the datatype of anything. Based on what value you
assign, Python keeps track of the datatype internally.

suppose "bucky"[3]
output:'k'

12: Something cool with the Lists:

	Slicing: 
	ex: example=[0,1,2,3,4,5,6,7,8,9]
	so when we do example[4:8] = it will show you output like >>> 4,5,6,7 so it will sclice the list it includes 4 and excludes 8
			     [4:9]>>>4,5,6,7,8 it will not include 9 . so to include 9 do like [4:10] or like [4:]
	simillarly if u backwords the list [-5:-1]>>>5,6,7,8
	if u want from start use [:7]>>> 0,1,2,3,4,5,6
	[:] will give you whole string	
	one more thing you can use third more parameter as increment like [1:8:2]>>>1,3,5,7
so in list u can traverse from right to left and from left to right using positive/negative sequencing.	

you can add sequences like : [4,5,6]+[7,8,9]>>>[4,5,6,7,8,9] simillarly 'bucky'+'roberts' but u cant do like: 'bucky'+[4,5,6]

if u write like 'bucky'*10 it will display 10 times but 21*10 =210 . so display it 10 times just do [21]*10

suppose we have string name='bucky'
now if we wanna check a perticular character is in the string then we can check it:
'k' in name>>>it will return true x in name>>> it will return false.

simillaly we can check like mom in family>>> it will return respectivr value.

You can change a word into a list using list function
Example = list(�kailas�)
Example= [�k�, �a�,�..]

You can replace a list value means:
Example[4:]=list(�baby�)
It will replace in example list from 4th position with baby list.
You can provide larger string.
So Example=[�k�,�a��i��l��b��a��b��y�]


How to add elements in the middle of the list:

Suppose example=[7,8,9]
So add example[1:1]=[3,3,3] so it will be like [7,3,3,3,8,9]

Now if you want to delete elements using slicing do like:
Example[1:5]=[]
Example=[7,9]



And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:

>>> x = [1,2,3,4,5,6]
>>> x[::-1]
[6,5,4,3,2,1]

Easy way to reverse sequences!

And if you wanted, for some reason, every second item in the reversed sequence:

>>> x = [1,2,3,4,5,6]
>>> x[::-2]
[6,4,2]



InBuilt_Functions in lists:
Difference between extends and append:
Append is used when you want to add as single element at the end of the list and extend is used when you want to add multiple values

len-length of list , max-gives highest value , min-gives lowest value.....etc

Adding Elements to Lists: li.append("new")
to add a element at a position : li.insert(2, "new")
extend concatenates lists. Note that you do not call extend with multiple arguments; you call it with one
argument, a list. In this case, that list has two elements

Example 3.11. The Difference between extend and append
>>> li = ['a', 'b', 'c']
>>> li.extend(['d', 'e', 'f'])
>>> li
['a', 'b', 'c', 'd', 'e', 'f']
>>> len(li)
6
>>> li[-1]
'f'
>>> li = ['a', 'b', 'c']
>>> li.append(['d', 'e', 'f'])
>>> li
['a', 'b', 'c', ['d', 'e', 'f']]
>>> len(li)
4
>>> li[-1]
['d', 'e', 'f']

Example 3.12. Searching a List
>>> li
['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']
>>> li.index("example")
5
>>> li.index("new")
2
>>>

Deleting List Elements
Example 3.13. Removing Elements from a List
>>> li
['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']
>>> li.remove("z")

Listname.sort method is used to sort the elements

Introducing Tuples:

A tuple is an immutable list. A tuple can not be changed in any way once it is created.:

t = ("a", "b", "mpilgrim", "z", "example")
>>> t
('a', 'b', 'mpilgrim', 'z', 'example')
>>> t[0]
'a'
>>> t[-1]
'example'
>>> t[1:3]
('b', 'mpilgrim')

A tuple is defined in the same way as a list, except that the whole set of elements is enclosed in parentheses
instead of square brackets.
The elements of a tuple have a defined order, just like a list. Tuples indices are zero-based, just like a list, so
the first element of a non-empty tuple is always t[0].
Negative indices count from the end of the tuple, just as with a list.
Slicing works too, just like a list. Note that when you slice a list, you get a new list; when you slice a tuple, you
get a new tuple.

Accessing Values in Tuples:

To access values in tuple, use the square brackets for slicing along with the index or indices to obtain value available at that index. For example ?

#!/usr/bin/python

tup1 = ('physics', 'chemistry', 1997, 2000);
tup2 = (1, 2, 3, 4, 5, 6, 7 );

print "tup1[0]: ", tup1[0]
print "tup2[1:5]: ", tup2[1:5]

When the above code is executed, it produces the following result ?

tup1[0]:  physics
tup2[1:5]:  [2, 3, 4, 5] 


Delete Tuple Elements

Removing individual tuple elements is not possible. There is, of course, nothing wrong with putting together another tuple with the undesired elements discarded.

To explicitly remove an entire tuple, just use the del statement. For example:

#!/usr/bin/python

tup = ('physics', 'chemistry', 1997, 2000);

print tup
del tup;
print "After deleting tup : "
print tup

This produces the following result. Note an exception raised, this is because after del tup tuple does not exist any more ?

('physics', 'chemistry', 1997, 2000)
After deleting tup :
Traceback (most recent call last):
  File "test.py", line 9, in <module>
    print tup;
NameError: name 'tup' is not defined


Tuples Have No Methods

You can't add elements to a tuple. Tuples have no append or extend method.
You can't remove elements from a tuple. Tuples have no remove or pop method.
You can't find elements in a tuple. Tuples have no index method.

t.index("example") 

Traceback (innermost last):
  File "<interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'index'

You can, however, use in to see if an element exists in the tuple.

>>> "z" in t           4
True

Updating Tuples

Tuples are immutable which means you cannot update or change the values of tuple elements. You are able to take portions of existing tuples to create new tuples as the following example demonstrates ?

#!/usr/bin/python

tup1 = (12, 34.56);
tup2 = ('abc', 'xyz');

# Following action is not valid for tuples
# tup1[0] = 100;

# So let's create a new tuple as follows
tup3 = tup1 + tup2;
print tup3

('Hi!',) * 4	('Hi!', 'Hi!', 'Hi!', 'Hi!')

To write a tuple containing a single value you have to include a comma, even though there is only one value ?

tup1 = (50,);



2.2.1. How Python's Datatypes Compare to Other Programming Languages
An erudite reader sent me this explanation of how Python compares to other programming languages:
statically typed language
A language in which types are fixed at compile time. Most statically typed languages enforce this by requiring
you to declare all variables with their datatypes before using them. Java and C are statically typed languages.
dynamically typed language
A language in which types are discovered at execution time; the opposite of statically typed. VBScript and
Python are dynamically typed, because they figure out what type a variable is when you first assign it a value.
strongly typed language
A language in which types are always enforced. Java and Python are strongly typed. If you have an integer,
you can't treat it like a string without explicitly converting it.
weakly typed language
A language in which types may be ignored; the opposite of strongly typed. VBScript is weakly typed. In
VBScript, you can concatenate the string '12' and the integer 3 to get the string '123', then treat that as
the integer 123, all without any explicit conversion

2.3. Documenting Functions:

You can document a Python function by giving it a doc string

def buildConnectionString(params):
"""Build a connection string from a dictionary of parameters.

Returns string."""
Triple quotes signify a multi-line string. Everything between the start and end quotes is part of a single string,
including carriage returns and other quote characters. You can use them anywhere, but you'll see them most often used
when defining a doc string.
Triple quotes are also an easy way to define a string with both single and double quotes, like qq/.../ in Perl.
Everything between the triple quotes is the function's doc string, which documents what the function does. A
doc string, if it exists, must be the first thing defined in a function (that is, the first thing after the colon). You
don't technically need to give your function a doc string, but you always should. I know you've heard this in
every programming class you've ever taken, but Python gives you an added incentive: the doc string is available
at runtime as an attribute of the function.
Many Python IDEs use the doc string to provide context-sensitive documentation, so that when you type a
function name, its doc string appears as a tooltip. This can be incredibly helpful, but it's only as good as the doc
strings you write.

Everything in Python is an object, and almost everything has attributes and methods. All functions have a built-in
attribute __doc__, which returns the doc string defined in the function's source code. The sys module is an
object which has (among other things) an attribute called path. And so forth.
Still, this begs the question. What is an object? Different programming languages define "object" in different ways. In
some, it means that all objects must have attributes and methods; in others, it means that all objects are subclassable.
In Python, the definition is looser; some objects have neither attributes nor methods (more on this in Chapter 3), and
not all objects are subclassable (more on this in Chapter 5). But everything is an object in the sense that it can be
assigned to a variable or passed as an argument to a function (more in this in Chapter 4).

"everything in Python is an object"


2.5. Indenting Code


Python functions have no explicit begin or end, and no curly braces to mark where the function code starts and
stops. The only delimiter is a colon (:) and the indentation of the code itself. Means if you are writing the function like 
def hello():
  print �kailas�
so here print is written after two spaces if you try to write the print statement before two spaces it will throw you an error. In IDE indentation is done automatically while typing the code

So this is the common error
 

Code blocks are defined by their indentation. By "code block", I mean functions, if statements, for loops, while
loops, and so forth. Indenting starts a block and unindenting ends it. There are no explicit braces, brackets, or
keywords. This means that whitespace is significant, and must be consistent. In this example, the function code
(including the doc string) is indented four spaces. It doesn't need to be four spaces, it just needs to be consistent.
The first line that is not indented is outside the function


def fib(n):
print 'n =', n
if n > 1:
return n * fib(n - 1)
else:
print 'end of the line'
return 1

This is a function named fib that takes one argument, n. All the code within the function is indented.
Printing to the screen is very easy in Python, just use print. print statements can take any data
type, including strings, integers, and other native types like dictionaries and lists that you'll learn about
in the next chapter. You can even mix and match to print several things on one line by using a
comma-separated list of values. Each value is printed on the same line, separated by spaces (the
commas don't print). So when fib is called with 5, this will print "n = 5".
if statements are a type of code block. If the if expression evaluates to true, the indented block is
executed, otherwise it falls to the else block.
Of course if and else blocks can contain multiple lines, as long as they are all indented the same
amount. This else block has two lines of code in it. There is no other special syntax for multi-line
code blocks. Just indent and get on with your life.
Example with elseif

tuna="kailas"
if tuna=="kail":
    print 'hi kail'
elif tuna=='kailas':
    print 'hi kailas'
else:
    print  'hi  anonymous'


3.Introducing Dictionaries:

One of Python's built-in datatypes is the dictionary, which defines one-to-one relationships between keys and values
A dictionary in Python is like an instance of the Hashtable class in Java.

Example 3.1. Defining a Dictionary
>>> d = {"server":"mpilgrim", "database":"master"}
>>> d
{'server': 'mpilgrim', 'database': 'master'}
>>> d["server"]
'mpilgrim'
>>> d["database"]
'master'
>>> d["mpilgrim"]
Traceback (innermost last):
File "<interactive input>", line 1, in ?
KeyError: mpilgrim

First, you create a new dictionary with two elements and assign it to the variable d. Each element is a
key-value pair, and the whole set of elements is enclosed in curly braces.
'server' is a key, and its associated value, referenced by d["server"], is 'mpilgrim'.
'database' is a key, and its associated value, referenced by d["database"], is 'master'.
You can get values by key, but you can't get keys by value. So d["server"] is 'mpilgrim', but
d["mpilgrim"] raises an exception, because 'mpilgrim' is not a key.


Example 3.2. Modifying a Dictionary
>>> d
{'server': 'mpilgrim', 'database': 'master'}
>>> d["database"] = "pubs"
>>> d
{'server': 'mpilgrim', 'database': 'pubs'}
>>> d["uid"] = "sa"
>>> d
{'server': 'mpilgrim', 'uid': 'sa', 'database': 'pubs'}

You can not have duplicate keys in a dictionary. Assigning a value to an existing key will wipe out the
old value.
You can add new key-value pairs at any time. This syntax is identical to modifying existing values

When working with dictionaries, you need to be aware that dictionary keys are case-sensitive

Deleting Items from a Dictionary:del d["database"]

clear deletes all items from a dictionary


3.4. Declaring variables

Python has local and global variables like most other languages, but it has no explicit variable declarations. Variables
spring into existence by being assigned a value, and they are automatically destroyed when they go out of scope.
backslash ("\") serving as a
line-continuation marker.
Strictly speaking, expressions in parentheses, straight brackets, or curly braces (like defining a dictionary) can be split
into multiple lines with or without the line continuation character ("\"). I like to include the backslash even when it's
not required because I think it makes the code easier to read, but that's a matter of style.

3.4.2. Assigning Multiple Values at Once
One of the cooler programming shortcuts in Python is using sequences to assign multiple values at once.
Example 3.19. Assigning multiple values at once
>>> v = ('a', 'b', 'e')
>>> (x, y, z) = v
>>> x
'a'
>>> y
'b'
>>> z
'e'

is a tuple of three elements, and (x, y, z) is a tuple of three variables. Assigning one to the other
assigns each of the values of v to each of the variables, in order.
This has all sorts of uses. I often want to assign names to a range of values. In C, you would use enum and manually
list each constant and its associated value, which seems especially tedious when the values are consecutive. In Python,
you can use the built-in range function with multi-variable assignment to quickly assign consecutive values.



Example 3.20. Assigning Consecutive Values
>>> range(7)
[0, 1, 2, 3, 4, 5, 6]
>>> (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)
>>> MONDAY
0
>>> TUESDAY
1
>>> SUNDAY

The built-in range function returns a list of integers. In its simplest form, it takes an upper limit and returns a
zero-based list counting up to but not including the upper limit. (If you like, you can pass other parameters to
specify a base other than 0 and a step other than 1. You can print range.__doc__ for details.)
MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, and SUNDAY are the variables you're
defining. (This example came from the calendar module, a fun little module that prints calendars, like the
UNIX program cal. The calendar module defines integer constants for days of the week.)
Now each variable has its value: MONDAY is 0, TUESDAY is 1, and so forth.

List Comprehensions
List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition.

For example, assume we want to create a list of squares, like:
A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal:

>>>
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

Tuples and Sequences:

>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')

>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])


>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])


As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists.

Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain an heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of namedtuples). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list.

5.4. Sets
Python also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference.

Curly braces or the set() function can be used to create sets. Note: to create an empty set you have to use set(), not {}; the latter creates an empty dictionary, a data structure that we discuss in the next section.

Here is a brief demonstration:

>>>
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> fruit = set(basket)               # create a set without duplicates
>>> fruit
set(['orange', 'pear', 'apple', 'banana'])
>>> 'orange' in fruit                 # fast membership testing
True
>>> 'crabgrass' in fruit
False

>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a                                  # unique letters in a
set(['a', 'r', 'b', 'c', 'd'])
>>> a - b                              # letters in a but not in b
set(['r', 'd', 'b'])
>>> a | b                              # letters in either a or b
set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])
>>> a & b                              # letters in both a and b
set(['a', 'c'])
>>> a ^ b                              # letters in a or b but not both
set(['r', 'd', 'b', 'm', 'z', 'l'])

3.5. Formatting Strings:

Python supports formatting values into strings. Although this can include very complicated expressions, the most
basic usage is to insert values into a string with the %s placeholder

>>> k = "uid"
>>> v = "sa"
>>> "%s=%s" % (k, v)
'uid=sa'
The whole expression evaluates to a string. The first %s is replaced by the value of k; the second %s is replaced
by the value of v. All other characters in the string (in this case, the equal sign) stay as they are.
Note that (k, v) is a tuple. I told you they were good for something.

Example 3.22. String Formatting vs. Concatenating
>>> uid = "sa"
>>> pwd = "secret"
>>> print pwd + " is not a good password for " + uid
secret is not a good password for sa
>>> print "%s is not a good password for %s" % (pwd, uid)


secret is not a good password for sa

Another Ex. Bucky=�Hey there %s , how is your %s�
Varb=(�betty�, �foot�)
Print Bucky % verb >>> Hey there betty , how is your foot

Now you can use fun like: Bucky.find(�there�)>>>4 it will give you position including spaces
>>> userCount = 6
>>> print "Users connected: %d" % (userCount, )
Users connected: 6
>>> print "Users connected: " + userCount
Traceback (innermost last):
File "<interactive input>", line 1, in ?
TypeError: cannot concatenate 'str' and 'int' objects
+ is the string concatenation operator.
In this trivial case, string formatting accomplishes the same result as concatentation.
(userCount, ) is a tuple with one element. Yes, the syntax is a little strange, but there's a good reason for
it: it's unambiguously a tuple. In fact, you can always include a comma after the last element when defining a
list, tuple, or dictionary, but the comma is required when defining a tuple with one element. If the comma
weren't required, Python wouldn't know whether (userCount) was a tuple with one element or just the value
of userCount.
String formatting works with integers by specifying %d instead of %s.
Trying to concatenate a string with a non?string raises an exception. Unlike string formatting, string
concatenation works only when everything is already a string.
As with printf in C, string formatting in Python is like a Swiss Army knife. There are options galore, and modifier
strings to specially format many different types of values.
3.6. Mapping Lists
One of the most powerful features of Python is the list comprehension, which provides a compact way of mapping a
list into another list by applying a function to each of the elements of the list


>>> li = [1, 9, 8, 4]
>>> [elem*2 for elem in li]
[2, 18, 16, 8]
>>> li
[1, 9, 8, 4]
>>> li = [elem*2 for elem in li]
>>> li
[2, 18, 16, 8]

>>> li = [2, 3, 4,]  -----> these are integers
>>> li = [elem*3 for elem in li]
>>> li
[6, 9, 12]
>>> li = ['3', '4'] -------> these are strings
>>> li = [elem*3 for elem in li]
>>> li
['333', '444']
>>>


To make sense of this, look at it from right to left. li is the list you're mapping. Python loops through li one
element at a time, temporarily assigning the value of each element to the variable elem. Python then applies
the function elem*2 and appends that result to the returned list.
Note that list comprehensions do not change the original list.
It is safe to assign the result of a list comprehension to the variable that you're mapping. Python constructs the
new list in memory, and when the list comprehension is complete, it assigns the result to the variable.

Example 3.25. The keys, values, and items Functions
>>> params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}
>>> params.keys()
['server', 'uid', 'database', 'pwd']
>>> params.values()
['mpilgrim', 'sa', 'master', 'secret']
>>> params.items()
[('server', 'mpilgrim'), ('uid', 'sa'), ('database', 'master'), ('pwd', 'secret')]
The keys method of a dictionary returns a list of all the keys. The list is not in the order in
which the dictionary was defined (remember that elements in a dictionary are unordered),
but it is a list.
The values method returns a list of all the values. The list is in the same order as the list
returned by keys, so params.values()[n] == params[params.keys()[n]]
for all values of n.
The items method returns a list of tuples of the form (key, value). The list contains
all the data in the dictionary.
Now let's see what buildConnectionString does. It takes a list, params.items(), and maps it to a new list
by applying string formatting to each element. The new list will have the same number of elements as
params.items(), but each element in the new list will be a string that contains both a key and its associated value
from the params dictionary.

Example 3.26. List Comprehensions in buildConnectionString, Step by Step
>>> params = {"server":"mpilgrim", "database":"master", "uid":"sa", "pwd":"secret"}
>>> params.items()
[('server', 'mpilgrim'), ('uid', 'sa'), ('database', 'master'), ('pwd', 'secret')]
>>> [k for k, v in params.items()]
['server', 'uid', 'database', 'pwd']
>>> [v for k, v in params.items()]
['mpilgrim', 'sa', 'master', 'secret']
>>> ["%s=%s" % (k, v) for k, v in params.items()]
['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret']
Note that you're using two variables to iterate through the params.items() list. This is another use of
multi?variable assignment. The first element of params.items() is ('server', 'mpilgrim'), so in
the first iteration of the list comprehension, k will get 'server' and v will get 'mpilgrim'. In this case,
you're ignoring the value of v and only including the value of k in the returned list, so this list comprehension
ends up being equivalent to params.keys().
Here you're doing the same thing, but ignoring the value of k, so this list comprehension ends up being
equivalent to params.values().
Combining the previous two examples with some simple string formatting, you get a list of strings that include
both the key and value of each element of the dictionary. This looks suspiciously like the output of the program.
All that remains is to join the elements in this list into a single string

3.7. Joining Lists and Splitting Strings:

You have a list of key?value pairs in the form key=value, and you want to join them into a single string. To join
any list of strings into a single string, use the join method of a string object.
Here is an example of joining a list from the buildConnectionString function:
return ";".join(["%s=%s" % (k, v) for k, v in params.items()])
One interesting note before you continue. I keep repeating that functions are objects, strings are objects... everything is
an object. You might have thought I meant that string variables are objects. But no, look closely at this example and
you'll see that the string ";" itself is an object, and you are calling its join method.
The join method joins the elements of the list into a single string, with each element separated by a semi?colon. The
delimiter doesn't need to be a semi?colon; it doesn't even need to be a single character. It can be any string


Join:

Sequence=[�hey�,�there�,�hoss�]
Glue=�hoss�
Glue.join(sequence)>>>�heyhosstherehosshosshoss�

String Functions:

Randstr=�I have No idea�

You can use functions like Randstr.lower
Randstr.replace(�have�,�has�)

Compariosion:

One = [21,22,23]
Two= [21,22,23]
One==Two
>>>true
One is Two 
>>>false

One = Two = [21,22,23]
One is Two
>>> true bcos they are the same objects

And or :

Eg.
Example=4

If example>2 and example<6:
Print �hi number is 4� 
If example>3 or example<2
Print �hi num is 4�

LOOP:


While loop:

B=1
While b<=10:
Print b
B+=1

For loop:

IDLE 1.2.5      
>>> gl = ['bread', 'milk', 'toast']
>>> gl
['bread', 'milk', 'toast']
>>> for food in gl:
	print "I want to eat" +food

	
I want to eatbread
I want to eatmilk
I want to eattoast
>>>

Accepting user input using for loop:


>>> def acc(x):
...   for i in range(5):
...     input("Enter num")
...
>>>
>>> acc(4)
Enter num3
Enter num3
Enter num4
Enter num5
Enter num5
>>>

For loop for Dectionary:

>>> kb={"kailas":"bidve", "shubham":"bankar"}
>>> for item in kb:
	print 'I want this' +item

	
I want thiskailas
I want thisshubham
>>> for item in kb:
	print "hi..." +item , kb[item]

	
hi...kailas bidve
hi...shubham bankar
>>>

>>> while 1:
	name = raw_input("Enter Name:")
	if name=='quit': break

	
Enter Name:kailas
Enter Name:shubham
Enter Name:quit
>>>

Function in Python:

>>> def whatsup(x):
	print 'whatsup '+x

	
>>> print whatsup('kailas')
whatsup kailas



When we don�t know the number of parameters required while calling the function then:
Def list(*food):

If we put * infront od the parameter then it will consider that there are number of parameters are going to use
Ex.1.
>>> def list(*k)
SyntaxError: invalid syntax
>>> def list(*k):
	print k

	
>>> list('kailas')
('kailas',)
>>>

Ex.2.
>>> def list(*x):
	print x

	
>>> list('kailas','bidve')
('kailas', 'bidve')
>>>

So as you can see when you pass the arguments it converts it to tuples
Parameters are converted to touples

So if you want to convert the parameters to Dictionary just put ** infront of the function argumrent


>>> def cart(**item):
	print item

	
>>> cart(apple=5, banana=4, mango=12)
{'mango': 12, 'apple': 5, 'banana': 4}
>>>

Ex.3.


>>> def profile(first,last,*age,**item):
	print first, last
	print age
	print item

	
>>> profile(kailas, bidve,24,pizza,burger,ice-cream)

Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    profile(kailas, bidve,24,pizza,burger,ice-cream)
NameError: name 'kailas' is not defined
>>> profile('kailas', 'bidve',24,56,pizza=3,burger=5,ice-cream=6)
SyntaxError: keyword can't be an expression
>>> profile('kailas', 'bidve',24,56 , pizza=3,burger=5)
kailas bidve
(24, 56)
{'burger': 5, 'pizza': 3}
>>>


Here now how computer is defferntiate between dictionary and tuppel entry�.it recognize it bcos in dictionary we needs = sign

Now here you can use vice versa means you can convert touple/dictionary to parameters

>>> def example(a,b,c)
SyntaxError: invalid syntax
>>> def example(a,b,c):
	return a*b+c

>>> tuna=(2,3,4)
>>> example(*tuna)
10
>>>

Here example is a function which uses three arguments a,b,c and we have defined touple tuna . we are passing it to example . as it is an touple we are using * here.

Ex. Of Dectionary as parameter:

>>> def example(**x)
SyntaxError: invalid syntax
>>> def example(**x):
	print x

	
>>> dec={"kailas":2, "shubham":3}
>>> example(**dec)
{'kailas': 2, 'shubham': 3}
>>>
Python __init__ and self what do they do?

class A(object):
    def __init__(self):
        self.x = 'Hello'

    def method_a(self, foo):
        print self.x + ' ' + foo
... the�self�variable represents the instance of the object itself. Most object-oriented languages pass this as a hidden parameter to the methods defined on an object; Python does not. You have to declare it explicitly. When you create an instance of the�A�class and call its methods, it will be passed automatically, as in ...
a = A()               # We do not pass any argument to the __init__ method
a.method_a('Sailor!') # We only pass a single argument
The�__init__�method is roughly what represents a constructor in Python. When you call�A()�Python creates an object for you, and passes it as the first parameter to the�__init__�method. Any additional parameters (e.g.,�A(24, 'Hello')) will also get passed as arguments--in this case causing an exception to be raised, since the constructor isn't expecting them.

Here we declared a function which accepts dictionary so we are declaring its argument with ** . now we declared a dictionary dec and passed it using ** so here on both the location we are using **


Classes ans Self:

Ex.

Class classname:

	Def accept(self, name):

		Self.name=name
     Def display(self, name):
		Return self.name
	Def saying(self):
	Print �Hello %s� %self.name
>>>first= className()
>>>second=className()
>>>first.accept(�kailas�)
>>>second.accept(�shubham�)



Points:

Define class using the keyword class keyword , declare the function using def . here we have created the objects first , second and passing value as kailas . here main point we should focus on is �self� here it is used as place order for object. Means when we call a function we are passing the object it will replace the self with object .

We put self bcos we don�t know what the object name will be. So it will be filled with the object name. So finally self is a temporary placeorder for object name.


Inheritance:


Ex. 
>>> class parent:
	var1="kailas"
	var2="bidve"

	
>>> class child(parent):
      pass

>>> p=parent()
>>> c=child()
>>> p.var1
'kailas'

'bidve'
>>> c.var1
'kailas'
>>> c.var2
'bidve'
>>>



Have a look over here , so if you want to inherite any class just put that classname as a parameter in the subclass. Here pass means I don�t want to do anything in sub class.


So if you want to inherite multiple classes you can do so by passing multiple parent classes as parametres :
Ex. Class child(parent, parent1)

Constructor in Python:

>>> class new:
	def __init__(self):
		print "hi...how are you"

		
>>> n=new()
hi...how are you
>>>

Here is the constructor , define constructor with two underscore then init and again two underscore , so when you call the object the constructor will be automatically called

Module in Python:

When you exit from python module all declared variables , methods will be lost , so to avoide this , save all the variables and function in a module so that you can import it.

Click on new windows , declare all the variables/functions save it in the folder python25 whichever version you are using . bcos modules should be at the same location where you have installed it python  will look at that location 
Ex. 
>>> import module
>>> module.display()
hi....
>>>

Here module is the module we have declared and we have defined a method called display in it so here we are importing it and using it.

Note one thing about module that once you open a IDE and imported the module once and made some changes in the module it will not be affective.
So to avoid this you can use the reload method. So that it will reload the changes you have made.
Ex. reload(module name)

You can also assign the module to a variable :
Ex.baby=test.display
>>>baby()


Module Info :

Every module has different functions , so to know about module u can do one thing: 
Dir(math)
Help(math)=provides how all the functions from this module works
Math.__doc__=provide the documentation information about math




Working With File:

>>> fob=open('C:/test/a.txt','w')
>>> fob.write('hi....how r u')
>>> fob.close
<built-in method close of file object at 0x01C1CC80>
>>> fob.close()
>>>

Here we have created a object fob that object will be used to write into the file a.txt , so if you want to read from a file you have to create a different object. Remember one thing once you open the file , write/read from it you have to close it , to make it effective.

To read:

Fob=open('C:/test/a.txt','r')
Fob.read()= it will read whole file 
Now if you want to read first three bytes 
Fob.read(3)=hi.

We can read the file line by line:

Fob.readline()= will read the first line
Fob.readlines()= will read all the lines and will return the output in a list
 
To write line by line you can do one thing provide \n after each line , so that it will line by line
Fob.write(�hi�how r u \n this is 2nd line\n �)


How to modify a particular line:


>>> fob=open('C:/test/a.txt','r')
>>> listme=fob.readlines()
>>> listme
['India is my country\n', 'Huefikbfo efnwenfn\n', 'Hfcefpoijn dwednin\n', 'Rrr ssddw\n', '\n']
>>> listme[2]="good afternoon"
>>> listme
['India is my country\n', 'Huefikbfo efnwenfn\n', 'good afternoon', 'Rrr ssddw\n', '\n']
>>> fob.close()
>>>
>>> fob=open('C:/test/a.txt','w')
>>>fob.writelines(listme)
>>>fob.close()

As we know when we use the objectname with inbuilt function readlines it returns the output in the list and then we can modify the list and then while writing we can pass the modified list


Remember one thing always suppose you have opened the file to read you have to close it and if you want to write anything you need to open it in write mode and then close it


Note : Python checks only those things those which he tries to run
Means suppose in else condition we are trying to call a function that not exits and condition is true means it will not enter in else part so it will not throw any error bcos it will never enter into else part.
So unlike C/C++/JAVA it will not give any error it will run the program successfully
Means if we write a code in which part of it is wrong and that part is never going to execute it will not show you an error, it will run successfully


Strings are immutable in Python:

Suppose a=�hey�
>>>a+�how�
>>>�hey how�
Now if you print a
>>>a
>>>hey

So it means original value of the string never changes

>>> b="HEY"
>>> b.lower()
'hey'
>>> b
'HEY'
>>>

Command line argument:

To use command line argument you needs to import sys module
Then using sys.argv[] you can use the command line arguments

While running porgramm you have to pass the arguments


Note : In python 2 its Tkinter and in python 3 its tkinter



Why we use if __name__=__main__:

When the Python interpreter reads a source file, it executes all of the code found in it. Before executing the code, it will define a few special variables. For example, if the python interpreter is running that module (the source file) as the main program, it sets the special�__name__�variable to have a value�"__main__". If this file is being imported from another module,�__name__�will be set to the module's name.
In the case of your script, let's assume that it's executing as the main function, e.g. you said something like
python threading_example.py
on the command line. After setting up the special variables, it will execute the�import�statement and load those modules. It will then evaluate the�def�block, creating a function object and creating a variable called�myfunction�that points to the function object. It will then read the�if�statement and see that�__name__�does equal�"__main__", so it will execute the block shown there.
One of the reasons for doing this is that sometimes you write a module (a�.py�file) where it can be executed directly. Alternatively, it can also be imported and used in another module. By doing the main check, you can have that code only execute when you want to run the module as a program and not have it execute when someone just wants to import your module and call your functions themselves.
See�this page�for some extra details.


Anotther answer :

Python provides excellent introspection capabilities through object attributes and __name__ is one of them.

Like other programming languages, Python too has an execution entry point i.e. main. When you execute a Python script, it is treated as the main and its __name__ attribute is set to "__main__". If you import this script as a module in another script, the __name__ is set to the name of the script/module.

With this behavior any py file can exhibit dual behavior - it is a script as well as module. As a programmer, you can conditionally execute code based on whether it is being run as a script or is being imported as a module.

A very common use of this is to put test code of your script inside the if condition that you mentioned, while allowing others to use it as a module and not impacting their usage of the module.


Python's use of __new__ and __init__?

Use�__new__�when you need to control the creation of a new instance. Use�__init__�when you need to control initialization of a new instance.
__new__�is the first step of instance creation. It's called first, and is responsible for returning a new instance of your class. In contrast,�__init__�doesn't return anything; it's only responsible for initializing the instance after it's been created.
In general, you shouldn't need to override�__new__�unless you're subclassing an immutable type like str, int, unicode or tuple.




Understanding '*', '*args', '**' and '**kwargs'

Let's divide our work under five sections:
1. Understanding what '*' does from inside a function call.
2. Understanding what '*args' mean inside a function definition.
3. Understanding what '**' does from inside a function call.
4. Understanding what '**kwargs' mean inside a function definition.
5. A practical example of where we use 'args', 'kwargs' and why we use it.

Let's define a function "fun" which takes three positional arguments.
In [5]: def fun(a, b, c):
Call this function passing three positional arguments
In [7]: fun(1,2,3)
1 2 3 � � � � � � � � � � #Output

Its normal , now if  you define all three arguments in a list eg. L=[1,2,3] now here we will use * , while calling function fun(*l)
What did '*' do?
It unpacked the values in list 'l' as positional arguments. And then the unpacked values were passed to function 'fun' as positional arguments.
So, unpacking the values in list and changing it to positional arguments meant writing fun(*l) was equivalent to writing fun(1,2,3). Keep in mind that l=[1,2,3]. Let's try with some other value of 'l'.
Now if you pass l=[3,5,6,9] it will give you an error bcos:

list 'l' contains four values. So, when we tried 'fun(*l)', 'l' was unpacked so that its value could be sent as positional arguments. But, "l" has four values in it. So, writing 'fun(*l)' was equivalent to writing 'fun(3,5,6,9)'. But, 'fun' is defined to take only three positional arguments and hence we got this error. Similary, you can follow same steps with two values in list 'l' and notice the error.

Understanding what '*args' mean inside a function definition.

Let's change the function definition now.

Fun(*args)

Now call the function with one parameter , it will show you correct output , also same for more than one parameter 

In [21]: def fun(a, *args):
� �....: � � print "a is ", a
� �....: � � print "args is ", args
� �....: � � 


In [22]: fun(1, 2, 3, 4)
a is �1 � � � � � � � � � � � � � � � �#Output
args is �(2, 3, 4)
We can call "fun" with any number of arguments.

So, "**" unpacks the dictionary i.e the key values pairs in the dictionary as keyword arguments and these are sent as keyword arguments to the function being called. "*" unpacks a list/tuple i.e the values in the list as positional arguments and these are sent as positional arguments to the function being called.

What does "**kwargs" mean when used in a function definition?
With "**kwargs" in the function definition, kwargs receives a dictionary containing all the keyword arguments beyond the formal parameter list. Remember 'kwargs' will be a dictionary. In our previous two examples, when we printed kwargs, it printed a dictionary containing all the keyword arguments beyond the formal parameter list.
A practical example of where we use 'args', '*kwargs' and why we use it.
Whenever we inherit a class and override some of the methods of inherited class, we should use '*args' and '**kwargs' and pass the received positional and keyword arguments to the superclass 


How to use *args and **kwargs in Python
Date: 2008-01-03  |  Modified: 2012-12-20  |  Tags: core, python  |  97 Legacy Comments  |  1 Comment

Or, How to use variable length argument lists in Python.

The special syntax, *args and **kwargs in function definitions is used to pass a variable number of arguments to a function. The single asterisk form (*args) is used to pass a non-keyworded, variable-length argument list, and the double asterisk form is used to pass a keyworded, variable-length argument list. Here is an example of how to use the non-keyworded form. This example passes one formal (positional) argument, and two more variable length arguments.

def test_var_args(farg, *args):
    print "formal arg:", farg
    for arg in args:
        print "another arg:", arg

test_var_args(1, "two", 3)

Results:

formal arg: 1
another arg: two
another arg: 3


Here is an example of how to use the keyworded form. Again, one formal argument and two keyworded variable arguments are passed.

def test_var_kwargs(farg, **kwargs):
    print "formal arg:", farg
    for key in kwargs:
        print "another keyword arg: %s: %s" % (key, kwargs[key])

test_var_kwargs(farg=1, myarg2="two", myarg3=3)

Results:

formal arg: 1
another keyword arg: myarg2: two
another keyword arg: myarg3: 3


Examples

1.) def test_var_args(f_arg, *argv):
    print "first normal arg:", f_arg
    for arg in argv:
        print "another arg through *argv :", arg

test_var_args('yasoob','python','eggs','test')

This produces the following result:

first normal arg: yasoob
another arg through *argv : python
another arg through *argv : eggs
another arg through *argv 



Multithreading in Python:

There are two modules which support the usage of threads in Python:
* thread
and
* threading

Please note: The thread module has been considered as "deprecated" for quite a long time. Users have been encouraged to use the threading module instead. So,in Python 3 the module "thread" is not available anymore. But that's not really true: It has been renamed to "_thread" for backwards incompatibilities in Python3.�

The module "thread" treats a thread as a function, while the module "threading" is implemented in an object oriented way, i.e. every thread corresponds to an object.


It's possible to execute functions in a separate thread with the module Thread. To do this, we can use the function thread.start_new_thread:

thread.start_new_thread(function, args[, kwargs])�

This methode starts a new thread and return its identifier. The thread executes the function "function" (function is a reference to a function) with the argument list args (which must be a list or a tuple). The optional kwargs argument specifies a dictionary of keyword arguments. When the function returns, the thread silently exits. When the function terminates with an unhandled exception, a stack trace is printed and then the thread exits (but other threads continue to run).�

Starting a New Thread:
To spawn another thread, you need to call following method available in thread module:
thread.start_new_thread ( function, args[, kwargs] )
This method call enables a fast and efficient way to create new threads in both Linux and Windows.
The method call returns immediately and the child thread starts and calls function with the passed list of agrs. When function returns, the thread terminates.
Here, args is a tuple of arguments; use an empty tuple to call function without passing any arguments. kwargs is an optional dictionary of keyword argument
The Threading Module:
The newer threading module included with Python 2.4 provides much more powerful, high-level support for threads than the thread module discussed in the previous section.
The threading module exposes all the methods of the thread module and provides some additional methods:
* threading.activeCount(): Returns the number of thread objects that are active.
* threading.currentThread(): Returns the number of thread objects in the caller's thread control.
* threading.enumerate(): Returns a list of all thread objects that are currently active.
In addition to the methods, the threading module has the Thread class that implements threading. The methods provided by the Thread class are as follows:
* run(): The run() method is the entry point for a thread.
* start(): The start() method starts a thread by calling the run method.
* join([time]): The join() waits for threads to terminate.
* isAlive(): The isAlive() method checks whether a thread is still executing.
* getName(): The getName() method returns the name of a thread.
* setName(): The setName() method sets the name of a thread.
Creating Thread using Threading Module:
To implement a new thread using the threading module, you have to do the following:
* Define a new subclass of the Thread class.
* Override the __init__(self [,args]) method to add additional arguments.
* Then, override the run(self [,args]) method to implement what the thread should do when started.
Once you have created the new Thread subclass, you can create an instance of it and then start a new thread by invoking the start(), which will in turn call run() method.
Example:
#!/usr/bin/python

import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self) ---->> IMP
        self.threadID = threadIDs
        self.name = name
        self.counter = counter
    def run(self):
        print "Starting " + self.name
        print_time(self.name, self.counter, 5)
        print "Exiting " + self.name

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            thread.exit()
        time.sleep(delay)
        print "%s: %s" % (threadName, time.ctime(time.time()))
        counter -= 1

# Create new threads
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# Start new Threads
thread1.start()
thread2.start()

print "Exiting Main Thread"
When the above code is executed, it produces the following result:
Starting Thread-1
Starting Thread-2
Exiting Main Thread
Thread-1: Thu Mar 21 09:10:03 2013
Thread-1: Thu Mar 21 09:10:04 2013
Thread-2: Thu Mar 21 09:10:04 2013
Thread-1: Thu Mar 21 09:10:05 2013
Thread-1: Thu Mar 21 09:10:06 2013
Thread-2: Thu Mar 21 09:10:06 2013
Thread-1: Thu Mar 21 09:10:07 2013
Exiting Thread-1
Thread-2: Thu Mar 21 09:10:08 2013
Thread-2: Thu Mar 21 09:10:10 2013
Thread-2: Thu Mar 21 09:10:12 2013
Exiting Thread-2


In above program if you remove line:
 c 

it will give you following error:

Traceback (most recent call last):
  File "C:\Build_Automation\NX2Builds\roughworkPracticeThread.py", line 16, in <module>
    ob = testThraed(1,"Thread-1")
  File "C:\Build_Automation\NX2Builds\roughworkPracticeThread.py", line 8, in __init__
    self.name=name
  File "C:\Python34\lib\threading.py", line 1094, in name
    assert self._initialized, "Thread.__init__() not called"
AttributeError: 'testThraed' object has no attribute '_initialized'

In Tkinter is there any way to make a widget not visible?

One option, as explained in another answer, is to use pack_forget or grid_forget. Another option is to use lift and lower. This changes the stacking order of widgets. The net effect is that you can hide widgets behind sibling widgets (or descendants of siblings). When you want them to be visible you lift them, and when you want them to be invisible you lower them. 
The advantage (or disadvantage...) is that they still take up space in their master. If you "forget" a widget, the other widgets might readjust their size or orientation, but if you raise or lower them they will not. 





Circular imports Error in Python:


In Python, things like def, class, and import are statements too.
Modules are executed during import, and new functions and classes won�t appear in the module�s namespace until the def (or class) statement has been executed.
This has some interesting implications if you�re doing recursive imports.
Consider a module X which imports module Y and then defines a function called spam:
    # module X

    import Y

    def spam():
        print "function in module x"
If you import X from your main program, Python will load the code for X and execute it. When Python reaches the import Y statement, it loads the code for Y, and starts executing it instead.
At this time, Python has installed module objects for both X and Y in sys.modules. But X doesn�t contain anything yet; the def spam statement hasn�t been executed.
Now, if Y imports X (a recursive import), it�ll get back a reference to an empty X module object. Any attempt to access the X.spam function on the module level will fail.
�
    # module Y

    from X import spam # doesn't work: spam isn't defined yet!
Note that you don�t have to use from-import to get into trouble:
    # module Y

    import X

    X.spam() # doesn't work either: spam isn't defined yet!
To fix this, either refactor your program to avoid circular imports (moving stuff to a separate module often helps), or move the imports to the end of the module (in this case, if you move import Y to the end of module X, everything will work just fine).

mports are pretty straightforward really. Just remember the following:
'import' and 'from xxx import yyy' are executable statements. They execute when the running program reaches that line.
If a module is not in sys.modules, then an import creates the new module entry in sys.modules and then executes the code in the module. It does not return control to the calling module until the execution has completed.
If a module does exist in sys.modules then an import simply returns that module whether or not it has completed executing. That is the reason why cyclic imports may return modules which appear to be partly empty.
Finally, the executing script runs in a module named __main__, importing the script under its own name will create a new module unrelated to __main__.
Take that lot together and you shouldn't get any surprises when importing modules. 












how to get the return value from a thread in python?

FWIW, the multiprocessing module has a nice interface for this using the Pool class. And if you want to stick with threads rather than processes, you can just use the multiprocessing.pool.ThreadPool class as a drop-in replacement.
One way I've seen is to pass a mutable object, such as a list or a dictionary, to the thread's constructor, along with a an index or other identifier of some sort. The thread can then store its results in its dedicated slot in that object. For example:


Got Following error while developing project:

Self.t1=something
Self.t2=something
Self.t3= something

Self.t1.start()
Self.t2.start()

while 1:    
                    if not self.t1.isAlive():
                        if not self.t2.isAlive():
                            self.t3.start()


Error : RuntimeError: threads can only be started once


The reason why threading.Thread is implemented that way is to keep correspondence between a thread object and operating system's thread. In major OSs threads can not be restarted, but you may create another thread with another thread id


Note : 

10 down vote accepted 
To make your code work in both Python 2 and 3 you can do something like this:
try:
    # for Python2
    from Tkinter import *
except ImportError:
    # for Python3
    from tkinter import *








Python Corse Notes(By Vikram):

https://class.coursera.org/pythonlearn-004/lecture/151�


Why this language has this name Python??

-->   Python was named after a famous British comedy show of 60�s and 70�s


Variable: A variable Is the named place in memory, where a programmer can store the data and later can retrieve the data using variable name 

Order of operations: 

1. Power -> multiplication/division -> addition/ subtraction


Python Knows the difference between integers , string and numbers
 
So if you write 1+5 it will give u 6 , if u write kai + las it will give kailas , so it knows that


Observation:


>>> x=10
>>> print("Hello",x)
Hello 10
>>> 
>>> 
>>> print("Hello"+x)
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    print("Hello"+x)
TypeError: Can't convert 'int' object to str implicitly
>>> print("Hello"+ str(x))
Hello10
>>>


Try Except:

Observe following different example:

kk='bob'

try:
    print("Hellow")
    kb=int(kk)
    print("done")
except:
    val=1
if val==1:
    print("Enter a valid option")


Output:
Hellow
Enter a valid option

Another Example:

kk='bob'

try:
    print("Hellow")
    kb=int(kk)
    print("done")
except:
    print("you r in expect")
print("out of form")


Output:

Hellow
you r in expect
out of form




raw_input or input(in python 3.x):

Python 2.x :

Python 2.5.5 (r255:77872, Jan 31 2010, 15:49:35) [MSC v.1310 32 bit (Intel)] on
win32
Type "help", "copyright", "credits" or "license" for more information.
>>> def foo():
...    n = input("Enter the n")
...    if n>10:
...     print "success"
...
>>>
>>> foo()
Enter the n25
success
>>>


>>> def foo():
...    n = raw_input("Enter the n")
...    if n>10:
...     print "success"
...
>>> foo()
Enter the n25
success
>>>
>>>

Python 3.X:

>>>
>>> def foo():
...    n = input("Enter the n")
...    if n>10:
...     print( "success")
...
>>> foo()
Enter the n15
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in foo
TypeError: unorderable types: str() > int()
>>>



Does raw_input only return a string type?
Maybe I'm missing something, but if you prompt the user with raw_input and store that value to a variable, you will always get a type:string. That's what I'm seeing, anyway, with this code:



You're correct, however I believe there is a function called int() that can turn your raw input into an integer
You can also use this to get your integer in one go, but I think it will throw some major errors if something else is entered
int(raw_input("Insert question here"))
so following program gives you an error:

print("Enter the Hours")
hours=input()
rate=10
if hours>40:
    x=hours-40
    charge=rate*40+x*(1.5*rate)
    print("total=",charge)
else:
    charge=hours*rate
    print("total=",charge)



Output:

Enter the Hours
12
Traceback (most recent call last):
  File "C:\Build_Automation\NX2Builds\roughwork3.py", line 5, in <module>
    if hours>40:
TypeError: unorderable types: str() > int()


Solution:


print("Enter the Hours")
hours=input()
hours= int(hours)
rate=10
if hours>40:
    x=hours-40
    charge=rate*40+x*(1.5*rate)
    print("total=",charge)
else:
    charge=hours*rate
    print("total=",charge)


Output:


Enter the Hours
12
total= 120



Note: To kill the program at any point you can use quit()

Note: Suppose if u define a function and never called it then it will not execute

Return Statement in python:
Observer the example:

def foo(p):
    if p=='ss':
        return "Hellow"
    
x='ss'
print(foo(x), 'Kailas')
Output:
Hellow Kailas


Difference between While Loop and for loop:

While loops are called as indefinite loops because they keep going until a logical condition becomes false.
For Loops are called as definite loops because  they execute anexact no of times



Loops and Iterations:


for i in [1, 2,3 ,4, 56]:
    print(i)

friends =['kk', 'eedwefcr', 'wefwrf', 'qwdwedfd']
for fr in friends:
    print("Hellow" , fr)


For loop take care of the incremebnts of counters




One of the most fundamental data structures in any language is the array. Python doesn't have a native array data structure, but it has the list which is much more general and can be used as a multidimensional array quite easily.


A list in Python is just an ordered collection of items which can be of any type. By comparison an array is an ordered collection of items of a single type - so in principle a list is more flexible than an array but it is this flexibility that makes things slightly harder when you want to work with a regular structure. A list is also a dynamic mutable type and this means you can add and delete elements from the list at any time.
To define a list you simply write a comma separated list of items in square brackets:


Is there a difference between `==` and `is` in Python?




is will return True if two variables point to the same object, == if the objects referred to by the variables are equal.

>>> a = [1, 2, 3]
>>> b = a
>>> b is a 
True
>>> b == a
True
>>> b = a[:]
>>> b is a
False
>>> b == a
True


The same holds true for string literals:

>>> "a" is "a"
True
>>> "aa" is "a" * 2
True
>>> x = "a"
>>> "aa" is x * 2
False
>>> "aa" is intern(x*2)
True


There is a simple rule of thumb to tell you when to use == or is.

    == is for value equality. Use it when you would like to know if two objects have the same value.
    is is for reference equality. Use it when you would like to know if two references refer to the same object.

In general, when you are comparing something to a simple type, you are usually checking for value equality, so you should use ==. For example, the intention of your example is probably to check whether x has a value equal to 2 (==), not whether x is literally referring to the same object as 2.


Accessing Elements of Lists:

>>> animal=['kk', 'bb']
>>> print(animal[0])
kk
>>> 






Arrays in Python
Written by Alex Armstrong   
Monday, 19 March 2012
Article Index
Arrays in Python
Dimensions and Comprehensions
Page 2 of 2
Dimension?

So far everything is going according to plan. Where things start to go wrong just a little is when you attempt to push the similarities between lists and arrays one step too far. For example, suppose you want to create an array initialized to a particular value. Following the general array idiom in most languages you might write:

myList=[]
for i in range(10):
 myList[i]=1

only to discover that this doesn't work because you can't assign to a list element that doesn't already exist.

One solution is to use the append method to add elements one by one:

myList=[]
for i in range(10):
 myList.append(1)

This works but it only works if you need to build up the list in this particular order - which most of the time you do. When the same situation arises in two- and multi-dimensioned arrays the problem often isn't as easy to solve with append, and there is a better way.

When you create an array in other languages you can usually perform operations like:

a[i]=0

without having to worry if a[i] already exists. In many cases the cost of this facility is that you have to declare the size of the array using a dimension statement of some sort. Python doesn't have such a facility because lists are dynamic and don't have to be "dimensioned". It is fairly easy to do the same job as a dimension statement, however, using a "comprehension".
Comprehensions

A comprehension is roughly speaking just an expression that specifies a sequence of values - think of it as a compact for loop. In Python a comprehension can be used to generate a list.

This means that we can use a comprehension to initialize a list so that it has a predefined size. The simplest form of a list comprehension is

[expression for variable in list]

For example, to create the list equivalent of a ten-element array you could write:

myList=[0 for i in range(10)]

Following this you have a ten-element list and you can write

myList[i]=something

without any worries - as long as i<10.

You can also use the for variable in the expression. For example:

myList=[i for i in range(10)]

sets myList to [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] and

myList=[i*i for i in range(10)]

sets myList to [0, 1, 4, 9, 16, 25, 36, 49, 64, 81].

The idea is that if you want to treat a list as an array then initializing it in this way can be thought of as the Python equivalent of dimensioning the array.
Two dimensions

It has to be said that one-dimensional arrays are fairly easy - it is when we reach two or more dimensions that mistakes are easy to make. For a programmer moving to Python the problem is that there are no explicit provisions for multidimensional arrays. As a list can contain any type of data there is no need to create a special two-dimensional data structure. All you have to do is store lists within lists - after all what is a two-dimensional array but a one-dimensional array of rows.

In Python a 2x2 array is [[1,2],[3,4]] with the list [1,2] representing the first row and the list [3,4] representing the second row. You can use slicing to index the array in the usual way. For example, if

myArray=[[1,2],[3,4]]

then

myArray[0]

is the list [1,2] and

myArray[0][1]

is [1,2][1], i.e. 2.

As long as you build your arrays as nested lists in the way described then you can use slicing in the same way as you would array indexing. That is:

myArray[i][j]

is the i,jth element of the array.

For example, to do something with each element in myArray you might write:

for i in range(len(myArray)):
 for j in range(len(myArray[i])):
  print myArray[i][j]

Where len(myArray) us used to get the number of rows and len(myArray[i])) to get the number of elements in a row. Notice that there is no need for all of the rows to have the same number of elements, but if you are using a list as an array this is an assumption you need to enforce.

Notice that in the two-dimensional case the non-indexed for loop can also prove useful, but you cannot avoid a nested loop:

for row in myArray:
 for e in row:
  print e

You can also use the index method to recover the i,j type index of an element, but you have to be careful how you do it. For example, to print the row and column index of the element:

for row in myArray:
 for e in row:
  print myArray.index(row),row.index(e)

Finally, we have the problem of initializing the array so that

myArray[i][j]=value

doesn't generate an error. In other words, what is the two-dimensional equivalent of the dimension statement using comprehensions?

The answer is that we need to use a nested comprehension to create the list. For example, to create a 3x3 matrix we could use:

myArray=[[0 for j in range(3)] for i in range(3)]

To understand this comprehension you need to see that the inner comprehension is just:

[0 for j in range(3)]

which creates a row, and then the outer comprehension just creates a list of rows.

As before, you can use the index variables in the expression. For example:

myArray=[[i*j for j in range(3)] for i in range(3)]

In general, if you want to work with an m by n array use:

myArray=[[0 for j in range(n)] for i in range(m)]

and everything should work as you would expect.
Advanced comprehensions

In Python there are lots of clever ways of doing things that you generally wouldn't dream of in a lesser language. For example, a comprehension can be used to generate a list based on other lists. It is generally easy to get hold of the rows of a matrix:

for row in myArray:
  do something with row

but getting at the columns as lists is much more difficult. However, with the help of a comprehension it is easy to get column j as a list:

col=[row[j] for row in myArray]

Using the same idea, if you want a transpose a matrix then usually you need to write two explicit for loops but to do the job in Python you can simply write:

myArray= [[row[i] for row in myArray] 
          for i in range(len(myArray))]

Python has lots of, usually functional, ways of working with arrays that aren't encountered in other languages. This should be enough to get you started on using lists as arrays and in more creative ways.


Accpeted array from user:


b=[]

for i in range(4):
        a=input("Enter the numbers")
        b.append(int(a))
for i in b:
        print(i)



Assignment:

count=0
sum=0
b=[]

while True:
        
        a=input("Enter the numbers")
        if str(a) =='done':   ///checks if user has entered the done
            break
        elif len(a)<1:      //if user enters empty string
            break
        else:
            a=int(a)  // as we know you need to always change user input to int/float bcos input takes by default string as input
            sum=sum+a
            count=count+1

ava=sum/count
print("avarage",ava)



To check if user has entered the wrong input:
for above program
:

	try:
                
                a=int(a)
                sum=sum+a
                count=count+1
            except:
                print("Invalid input")



Assignment :



a= input("Enter the number")
strt=a.find('@')// find returns the position of the character and if he didnt find the char it returns -1
print(strt)
ext=a[strt+1:]
ext=float(ext)
print(ext)



Output:

Enter the numberesfs@122
4
-1
122.0



File Operations:

still now we have been writing Python programm in main memory , commands were feeded to CPU

now we will work with secondary memory

to remove the white spaces use the function rstrip



print("Started")
test=open("test.txt",'w')  // creates a file if not present and opens in write mode
test.write("Hellow")
test.write("How are you??")
test.close()              //close the file once u done with the write operation
test1=open("test.txt", 'r') //opens the file in read operation
ss=test1.read() or print(test1.read())
print(ss.upper())  //converts the string to uppercase



LISTS:

1. List is a collections

Eg.

>>> a=["Kailas", "Bidve"]
>>> print(a[1])
Bidve
>>> 
>>> 
>>> 

2. Strings are immutable in Python means once you declared a string you cant change it:
Eg.
>>> b="Ganesh"
>>> b[0]='g'

Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    b[0]='g'
TypeError: 'str' object does not support item assignment
>>> 

Here I am trying to change Capital G with small 

3. Lists are muttable means you can change the list elements

EG.
>>> c=[11,12, 34]
>>> c[1]=56
>>> ptint(c)
>>> print(c[1])
56
>>>  print(c)
[11, 56, 34]
>>> 

4. Lists can be heterogeneous:

>>> ll=[13, 12, 'Kailas']
>>> print(ll)
[13, 12, 'Kailas']
>>> 

5. len Function returns the number of elements in the string
 >>>print len(ll)
3
>>> 

6. How to find put the last element of the list if you dont know the number of elements in the list(Asked by Vitthal):

Method 1:

>>> po[len(po)-1:]
[34]
>>> 

Method 2:

Using negative indexing:
>>> po[-1]
34
>>> 

Range Function:

Range is a function which returns the List
Eg.
>>> print range(4)
[0, 1, 2, 3]
>>> 


We can Concatinate the Lists using + sign:

Eg.

>>> kk=[12,23,34]
>>> kb=[34,45,56]
>>> kkkb=kk+kb
>>> print(kkkb)
[12, 23, 34, 34, 45, 56]
>>> 

List Methods:

>>> dir(kk)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__str__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> 


Thease are the method yo ucan use with the list

Empty List and then us Append():

>>> we=list[]
SyntaxError: invalid syntax
>>> we=list()
>>> 
>>> we=list()
>>> we.append(23)
>>> we.append(ihoiejfo)

Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    we.append(ihoiejfo)
NameError: name 'ihoiejfo' is not defined
>>> we.append("ihoiejfo")
>>> print(we)
[23, 'ihoiejfo']
>>> 

>>> 123 in we
False
>>> 23 in we
True
>>>

List function like : Sort , len, max , min, sum


Split String in List:

IDLE 1.2.5      
>>> abc="Kailas Ashok Bidve"
>>> kk=abc.split()
>>> print(kk)
['Kailas', 'Ashok', 'Bidve']
>>> 

1. For no of Spaces split consider it as a single space
2. You can send a parameter to split function like ';' so based on ';' it will split the string 
	NOte : Bydefault split occurs due to spaces

Dictionaries:

1. Dictionaries are the most powerful colletion in python
2. Dictionaries has different names in different languages:
	Associate array: PHP/Perl
	Java: Map/Hashmap
	property bag: C#/.net


Eg.

purs=dict()
purs['kv']=20
purs['erf']=22
print(purs)

Output: {'erf': 22, 'kv': 20}

print(purs['kv'])=20


Difference between Lists and Dictionaries:

A list keeps order, dict and set don't: when you care about order, therefore, you must use list (if your choice of containers is limited to these three, of course;-
dict associates with each key a value, while list and set just contain values: very different use cases, obviously

Dict dont mentain orders means if you print the purs sometimes it will print 

Ex.
 
purs=dict()
names=['kk', 'kb', 'kv', 'kb', 'kk']

for name in names:
    if name not in purs:
        purs[name]=1
    else:
        purs[name]=purs[name] + 1
    
print(purs) 

'In' operator applies for dictionaries

get() Method in Dectionaries:

if the key does not exists get method returns "None" by default

We can provide what it should return .

Ex.

>>> purse=dict()
>>> purse["Kaials"]=12
>>> purse["kk"]=22

>>> print(purse.get('kk'))
22
>>> print(purse.get('kn'))
None----> this is default value
>>> print(purse.get('kk',5))
22
>>> print(purse.get('kn',9))
9----> this we have provided 9
>>> 


If yo utry to add same entry twice in dectionory:

>>> purse=dict()
>>> purse["Kaials"]=12
>>> purse["Kaials"]=12
>>> print(purse)
{'Kaials': 12}
>>> 

>>> purse["Kaials"]=13
>>> print(purse)
{'Kaials': 13}
>>> 




Eg.

purs=dict()
ln=input("Enter teh input:")
words=ln.split()

for word in words:
    purs[word]=purs.get(word, 0)+1--> Here we are storing words from list into dictionary normally like purs[word]=0 or anything here we are applying the condition
    

print(purs)

Outout:

Enter teh input:my name is my
{'my': 2, 'name': 1, 'is': 1}


Ex.

purs=dict()
ln=["Kk", "LL", "mm"]

for word in ln:
    purs[word]=1

print(purs)

Getting List from Dictionary:

purs=dict()
purs= {"kb":1 , "ll":3, "ss":4}

print(list(purs))

output:

['ll', 'kb', 'ss']

print(purs.keys()):

output:dict_keys(['kb', 'll', 'ss'])

print(purs.values())

output:dict_values([3, 4, 1])

print(purs.items())
output:dict_items([('kb', 1), ('ll', 3), ('ss', 4)])----> It returns the tuple


BONUS: Python has two ineration variables:

purs=dict()
purs= {"kb":1 , "ll":3, "ss":4}
for aaa,bbb in purs.items():
    print(aaa,bbb)

output:

ll 3
kb 1
ss 4


Overall Programm(multiple concepts implementation):

bag=dict() ----> Empty Dictonary
fname=input("Enter input file name:")
handle = open(fname,'r') ->>file handler
text=handle.read()  ->>raeding file and saving in text

words=text.split() ->>spliting the text and will return it in the form of list

for word in words:
    bag[word]=bag.get(word,0)+1 ----> storing it into dictionary
						Benifit of using get() method is 						that for the first time it will 							search the string present in the 						dictionory if not will throw the key 						error , if we use get method it will 						return none or the value which we 						have provided
print(bag)

bigword=None
bigcount=0
for aaa,bbb in bag.items():--> bag.items() will return teh touple two 					variable are used to access the keyeord and 					values
    if bbb>bigcount:
        bigcount=bbb
        bigword=aaa
        
print(bigword,bigcount)



Output:

Enter input file name:C:\automation\Build_Automation\NX2Builds\assign.txt
{'kailas': 1, 'name': 1, 'cricket': 1, 'playing': 1, 'hobby': 1, 'my': 3, 'wedfhierhf': 1, 'is': 2}
my 3




TOUPLES:

Non changeble lists is touple

Difference: lists are muttable while touples are immutable(like Strings)

Like Strings touples are immutable(Means we cant change the values of the touple):

kk=("kdndn","eiohdfoewhf")
print(kk)
kk[1]="hhhh"

Output:

('kdndn', 'eiohdfoewhf')
Traceback (most recent call last):
  File "C:\Build_Automation\NX2Builds\roughWork.py", line 3, in <module>
    kk[1]="hhhh"
TypeError: 'tuple' object does not support item assignment



Things That you cant do with touples like Lists:

1.  you cant sort the touple -->kk.sort()
2. you cant append teh items in touple -->> kk.append(5)
3. you canr reverse th etouple->> kk.reverse()

List :

>>> l=list()
>>> dir(l)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__str__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> 


Touple:

>>> dir(t)
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmul__', '__setattr__', '__str__']

WHY to USE TUPLE:

they are much more efficiant -> fast accessible

So when things will not change then use tuple

you can use tuple on left side of the asssignment operator :

Eg.

>>> (x,y)=(5,6)
>>> print x
5
>>> print y
6
>>> 


Dictionary.items() returns the tuple 


** Tuples are comparable:

Eg.

>>> (4,5,6)<(7,8,9)
True
>>>

>>> ('kk' ,'ll')>('aa','bb')
True
>>>  


NOTE:  As we know if we use dictionary.items it returns list tuples so we can sort them.


eg.

d= dict()
d["kk"]=12
d["ll"]=14

t= sorted(d.items())
print(t)
print(d)

Output:

[('kk', 12), ('ll', 14)]
{'ll': 14, 'kk': 12}


Note : Indivisual tuple cant be change but as they are in list so they can be sorts
here we are sorting using keys

Sorting using Values:

Observe the following program neat:

d= dict()
d["kk"]=12     /// Declared a dectionary
d["ll"]=14
temp=list()   /// temporary created the list

for k,v in d.items():
    temp.append((v,k))    ///if you want to sort the list using values 					store it in temp list with reverse order
				observe "temp.append((v,k))  " double bracket

print(d)
print(temp)

temp.sort(reverse=True) ////we are using reverse bcos we want the list in 				decending order
print(temp) 



All in ONE:

Short and Smart Program:


d= dict()
d["kk"]=12
d["ll"]=14

print(d)
print( sorted( [ (v,k) for k,v in d.items()]) )


Observe the following program:

tot=0

for i in range(5):
    tot=tot+1  ---> Here we are adding 1 not i , I got confused
    
print(tot)

Output: 5


tot=0

for i in range(5):
    print(i)
    tot=tot+i
    
print(tot)

Output:

0
1
2
3
4
10


Please take the final before the deadline.  We canot move the exam deadline as we need to close down the grading to start the certificate process.  Regardless of when you complete the exam, you will not receive a certificate until some time after the exam deadline.  There is a separate process to run final grades and award certifiactes that cannot be started until after the exam is closed.



Python Advance Programming:

Python Sending Email using SMTP:

Simple Mail Transfer Protocol (SMTP) is a protocol, which handles sending e-mail and routing e-mail between mail servers.

Python provides smtplib module, which defines an SMTP client session object that can be used to send mail to any Internet machine with an SMTP or ESMTP listener daemon.

Here is a simple syntax to create one SMTP object, which can later be used to send an e-mail:

import smtplib

smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )




    host: This is the host running your SMTP server. You can specifiy IP address of the host or a domain name like tutorialspoint.com. This is optional argument.

    port: If you are providing host argument, then you need to specify a port, where SMTP server is listening. Usually this port would be 25.

    local_hostname: If your SMTP server is running on your local machine, then you can specify just localhost as of this option.


An SMTP object has an instance method called sendmail, which will typically be used to do the work of mailing a message. It takes three parameters:

    The sender - A string with the address of the sender.

    The receivers - A list of strings, one for each recipient.

    The message - A message as a string formatted as specified in the various RFCs



import smtplib-----> main library
from smtplib import SMTPException

user_name="bidvekailas@gmail.com"
user_pwd="passwordhide"
FROM='bidvekailas@gmail.com'
TO=['shubhs.bankar@gmail.com']
SUBJECT = "J1ch kay karnar aahe??"
TEXT="test mail"
message = """\From: %s\nTo: %s\nSubject: %s\n\n%s
            """ % (FROM, ", ".join(TO), SUBJECT, TEXT)


try:

server = smtplib.SMTP_SSL("smtp.gmail.com", 465) #or port 465 doesn't seem to work!
#server.ehlo()
#server.starttls()
server.login(user_name, user_pwd)
server.sendmail(FROM, TO, message)
                #server.quit()
server.close()
print('successfully sent the mail')

except SMTPException:
   print "Error: unable to send email"




Here, you have placed a basic e-mail in message, using a triple quote, taking care to format the headers correctly. An e-mail requires a From, To, and Subject header, separated from the body of the e-mail with a blank line.

To send the mail you use smtpObj to connect to the SMTP server on the local machine and then use the sendmail method along with the message, the from address, and the destination address as parameters (even though the from and to addresses are within the e-mail itself, these aren't always used to route mail).

If you're not running an SMTP server on your local machine, you can use smtplib client to communicate with a remote SMTP server. Unless you're using a webmail service (such as Hotmail or Yahoo! Mail), your e-mail provider will have provided you with outgoing mail server details that you can supply them, as follows:

smtplib.SMTP('mail.your-domain.com', 25)


Sending an HTML e-mail using Python:

When you send a text message using Python, then all the content will be treated as simple text. Even if you will include HTML tags in a text message, it will be displayed as simple text and HTML tags will not be formatted according to HTML syntax. But Python provides option to send an HTML message as actual HTML message.

While sending an e-mail message, you can specify a Mime version, content type and character set to send an HTML e-mail.


#!/usr/bin/python

import smtplib

message = """From: From Person <from@fromdomain.com>
To: To Person <to@todomain.com>
MIME-Version: 1.0
Content-type: text/html
Subject: SMTP HTML e-mail test

This is an e-mail message to be sent in HTML format

<b>This is HTML message.</b>
<h1>This is headline.</h1>
"""

try:
   smtpObj = smtplib.SMTP('localhost')
   smtpObj.sendmail(sender, receivers, message)         
   print "Successfully sent email"
except SMTPException:
   print "Error: unable to send email"



import smtplib
import base64

filename = "/tmp/test.txt"

# Read a file and encode it into base64 format
fo = open(filename, "rb")
filecontent = fo.read()
encodedcontent = base64.b64encode(filecontent)  # base64

sender = 'webmaster@tutorialpoint.com'
reciever = 'amrood.admin@gmail.com'

marker = "AUNIQUEMARKER"

body ="""
This is a test email to send an attachement.
"""
# Define the main headers.
part1 = """From: From Person <me@fromdomain.net>
To: To Person <amrood.admin@gmail.com>
Subject: Sending Attachement
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=%s
--%s
""" % (marker, marker)

# Define the message action
part2 = """Content-Type: text/plain
Content-Transfer-Encoding:8bit

%s
--%s
""" % (body,marker)

# Define the attachment section
part3 = """Content-Type: multipart/mixed; name=\"%s\"
Content-Transfer-Encoding:base64
Content-Disposition: attachment; filename=%s

%s
--%s--
""" %(filename, filename, encodedcontent, marker)
message = part1 + part2 + part3

try:
   smtpObj = smtplib.SMTP('localhost')
   smtpObj.sendmail(sender, reciever, message)
   print "Successfully sent email"
except Exception:
   print "Error: unable to send email"


14.3 Pickle

Python provides a standard module called pickle using which you can store
any Python object in a file and then get it back later. This is called storing the
object persistently.
Example (save as pickling.py):
import pickle
# the name of the file where we will store the object
shoplistfile = �shoplist.data�
# the list of things to buy
shoplist = [�apple�, �mango�, �carrot�]
# Write to the file
f = open(shoplistfile, �wb�)
pickle.dump(shoplist, f) # dump the object to a file
f.close()
del shoplist # destroy the shoplist variable

# Read back from the storage
f = open(shoplistfile, �rb�)
storedlist = pickle.load(f) # load the object from the file
print(storedlist)
Output:
$ python3 pickling.py
[�apple�, �mango�, �carrot�]


How It Works:
To store an object in a file, we have to first open the file in �w�rite �b�inary mode
and then call the dump function of thepickle module. This process is called
pickling.
Next, we retrieve the object using the load function of the pickle module which
returns the object. This process is called unpickling


Destroying Objects (Garbage Collection):

Python deletes unneeded objects (built-in types or class instances) automatically to free memory space. The process by which Python periodically reclaims blocks of memory that no longer are in use is termed garbage collection.

Python's garbage collector runs during program execution and is triggered when an object's reference count reaches zero. An object's reference count changes as the number of aliases that point to it changes.

An object's reference count increases when it's assigned a new name or placed in a container (list, tuple or dictionary). The object's reference count decreases when it's deleted with del, its reference is reassigned, or its reference goes out of scope. When an object's reference count reaches zero, Python collects it automatically.


Data Hiding:

An object's attributes may or may not be visible outside the class definition. For these cases, you can name attributes with a double underscore prefix, and those attributes will not be directly visible to outsiders.

class JustCounter:
   __secretCount = 0


Python Regular Expressions:


A regular expression is a special sequence of characters that helps you match or find other strings or sets of strings, using a specialized syntax held in a pattern. Regular expressions are widely used in UNIX world.

We would cover two important functions, which would be used to handle regular expressions.


The match Function

This function attempts to match RE pattern to string with optional flags.

Here is the syntax for this function:

re.match(pattern, string, flags=0)

Here is the description of the parameters:
Parameter	Description
pattern	This is the regular expression to be matched.
string	This is the string, which would be searched to match the pattern at the beginning of string.
flags	You can specify different flags using bitwise OR (|). These are modifiers, which are listed in the table below.

#!/usr/bin/python
import re

line = "Cats are smarter than dogs"

matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)

if matchObj:
   print "matchObj.group() : ", matchObj.group()
   print "matchObj.group(1) : ", matchObj.group(1)
   print "matchObj.group(2) : ", matchObj.group(2)
else:
   print "No match!!"

When the above code is executed, it produces following result:

matchObj.group() :  Cats are smarter than dogs
matchObj.group(1) :  Cats
matchObj.group(2) :  smarter



The search Function

This function searches for first occurrence of RE pattern within string with 





 flags.

Here is the syntax for this function:

re.search(pattern, string, flags=0)


Matching vs Searching:

Python offers two different primitive operations based on regular expressions: match checks for a match only at the beginning of the string, while search checks for a match anywhere in the string (this is what Perl does by default).
Example:

#!/usr/bin/python
import re

line = "Cats are smarter than dogs";

matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
   print "match --> matchObj.group() : ", matchObj.group()
else:
   print "No match!!"

searchObj = re.search( r'dogs', line, re.M|re.I)
if searchObj:
   print "search --> searchObj.group() : ", searchObj.group()
else:
   print "Nothing found!!"

When the above code is executed, it produces the following result:

No match!!
search --> matchObj.group() :  dogs


Search and Replace
One of the most important re methods that use regular expressions is sub.

Syntax
re.sub(pattern, repl, string, max=0)
This method replaces all occurrences of the RE pattern in string with repl, substituting all occurrences unless max provided. This method returns modified string.

Example
#!/usr/bin/python
import re

phone = "2004-959-559 # This is Phone Number"

# Delete Python-style comments
num = re.sub(r'#.*$', "", phone)
print "Phone Num : ", num

# Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print "Phone Num : ", num
When the above code is executed, it produces the following result ?

Phone Num :  2004-959-559
Phone Num :  2004959559
Regular Expression Modifiers: Option Flags
Regular expression literals may include an optional modifier to control various aspects of matching. The modifiers are specified as an optional flag. You can provide multiple modifiers using exclusive OR (|), as shown previously and may be represented by one of these ?

Modifier	Description
re.I	Performs case-insensitive matching.
re.L	Interprets words according to the current locale. This interpretation affects the alphabetic group (\w and \W), as well as word boundary behavior (\b and \B).
re.M	Makes $ match the end of a line (not just the end of the string) and makes ^ match the start of any line (not just the start of the string).
re.S	Makes a period (dot) match any character, including a newline.
re.U	Interprets letters according to the Unicode character set. This flag affects the behavior of \w, \W, \b, \B.
re.X	Permits "cuter" regular expression syntax. It ignores whitespace (except inside a set [] or when escaped by a backslash) and treats unescaped # as a comment marker.






^	Matches beginning of line.
$	Matches end of line.
.	Matches any single character except newline. Using m option allows it to match newline as well.


.	Match any character except newline
\d	Match a digit: [0-9]
\D	Match a nondigit: [^0-9]
\s	Match a whitespace character: [ \t\r\n\f]
\S	Match nonwhitespace: [^ \t\r\n\f]
\w	Match a single word character: [A-Za-z0-9_]
\W	Match a nonword character: [^A-Za-z0-9_]


Python CGI Programming:


The Common Gateway Interface, or CGI, is a set of standards that define how information is exchanged between the web server and a custom script.


Java vs. Python Productivity � an Overview

There are three main language characteristics that make programmers more productive with Python than with Java.
Java 	Python
statically typed

    In Java, all variable names (along with their types) must be explicitly declared. Attempting to assign an object of the wrong type to a variable name triggers a type exception.That�s what it means to say that Java is a statically typed language.

    Java container objects (e.g. Vector and ArrayList) hold objects of the generic type Object, but cannot hold primitives such as int. To store an int in a Vector, you must first convert the int to an Integer. When you retrieve an object from a container, it doesn�t remember its type, and must be explicitly cast to the desired type.

	dynamically typed

    In Python, you never declare anything. An assignment statement binds a name to an object, and the object can be of any type. If a name is assigned to an object of one type, it may later be assigned to an object of a different type. That�s what it means to say that Python is a dynamically typed language.

    Python container objects (e.g. lists and dictionaries) can hold objects of any type, including numbers and lists. When you retrieve an object from a container, it remembers its type, so no casting is required.

For more information on static vs. dynamic typing, see this post.
verbose

    �abounding in words; using or containing more words than are necessary�

	concise (aka terse)

    �expressing much in a few words. Implies clean-cut brevity, attained by excision of the superfluous�

not compact 	compact

In The New Hacker�s Dictionary, Eric S. Raymond gives the following definition for �compact�:

    Compact adj. Of a design, describes the valuable property that it can all be apprehended at once in one�s head. This generally means the thing created from the design can be used with greater facility and fewer errors than an equivalent tool that is not compact.

Example

The classic �Hello, world!� program illustrates the relative verbosity of Java.
Java 	Python

public class HelloWorld
{
    public static void main (String[] args)
    {
        System.out.println("Hellold!");
    }
}

	

print "Hello, world!"

print("Hello, world!") # Python version 3

Example

In the following example, we initialize an integer to zero, then convert it to a string, then check to see if it is empty. Note the data declaration (highlighted), which is necessary in Java but not in Python. Notice also how verbose Java is, even in an operation as basic as comparing two strings for equality.
Java 	Python

int    myCounter = 0;
String myString = String.valueOf(myCounter);
if (myString.equals("0")) ...

	

myCounter = 0
myString = str(myCounter)
if myString == "0": ...

// print the integers from 1 to 9
for (int i = 1; i < 10; i++)
{
   System.out.println(i);
}

	

 print the integers from 1 to 9
for i in range(1,10):
    print i


Example

Your application has 15 classes. (More precisely, it has 15 top-level public classes.)
Java 	Python
Each top-level public class must be defined in its own file. If your application has 15 such classes, it has 15 files. 	Multiple classes can be defined in a single file. If your application has 15 classes, the entire application could be stored in a single file, although you would probably want to partition it sensibly into perhaps 4, 5, or 6 files.
Example

In your application, method A calls B calls C calls D calls E calls F. You discover that F must throw exception SpecialException, and it must be caught by A.
Java 	Python
You must throw SpecialException in F, and catch it in A.
and
You must add �throws SpecialException� to the signatures of methods B, C, D, E, and F. 	You must raise SpecialException in F, and catch it in A.Exceptions will propagate upward automatically; there is nothing more that you must do.

The reason for this is that Java, virtually alone among object-oriented programming languages, uses checked exceptions � exceptions that must be caught or thrown by every method in which they might appear, or the code will fail to compile. Recently (as of June 2003) there seems to be an increasing amount of unhappiness with Java�s use of checked exceptions. See Bruce Eckel�s �Does Java need Checked Exceptions?� and Ron Waldhoff�s �Java�s checked exceptions were a mistake�.

As chromatic, the Technical Editor of the O�Reilly Network, put it:

    I like the idea of checked exceptions in some situations, but forcing every method to deal with (catching or throwing) all exceptions that its child calls or may call can be tedious. I�d rather be able to ignore an exception and let it propagate upwards. Sometimes, I�d rather not worry about exceptions at all.

Example

Your application has an Employee class. When an instance of Employee is created, the constructor may be passed one, two, or three arguments.

If you are programming in Java, this means that you write three constructors, with three different signatures. If you are programming in Python, you write only a single constructor, with default values for the optional arguments.
Java 	Python

public class Employee
{
    private String myEmployeeName;
    private int    myTaxDeductions = 1;
    private String myMaritalStatus = "single";

    //--------- constructor #1 -------------
    public Employee(String EmployeName)
    {
        this(employeeName, 1);
    }

    //--------- constructor #2 -------------
    public Employee(String EmployeName, int taxDeductions)
    {
       this(employeeName, taxDeductions, "single");
    }

    //--------- constructor #3 -------------
    public Employee(String EmployeName,
           int taxDeductions,
           String maritalStatus)
    {
       this.employeeName    = employeeName;
       this.taxDeductions   = taxDeductions;
       this.maritalStatus   = maritalStatus;
    }
...

	

class Employee():

    def __init__(self,
        employeeName
        , taxDeductions=1
        , maritalStatus="single"
        ):

        self.employeeName    = employeeName
        self.taxDeductions   = taxDeductions
        self.maritalStatus   = maritalStatus
...

In Python, a class has only one constructor.

The constructor method is simply another method of the class, but one that has a special name: __init__


Example

In Why Python? Eric S. Raymond notes that:

    Python � is compact � you can hold its entire feature set (and at least a concept index of its libraries) in your head.

In Why I Love Python Bruce Eckel notes that Java is not compact.

    I can remember many Python idioms because they�re simpler. That�s one more reason I program faster [in Python]. I still have to look up how to open a file every time I do it in Java. In fact, most things in Java require me to look something up.

Java 	Python

import java.io.*;
...

BufferedReader myFile =
    new BufferedReader(
        new FileReader(argFilename));

	

# open an input file
myFile = open(argFilename)

Example

Java�s string-handling capabilities are surprisingly weak. (But they have improved considerably with the addition of the split method to the String class in Java 1.4.)
Function or Method 	Java 	Python
Remove leading and trailing whitespace from string s 	s.trim() 	s.strip()
Remove leading whitespace from string s 	(not available) 	s.lstrip()
Remove trailing whitespace from string s 	(not available) 	s.rstrip()
Example

Code to add an int to a Vector, and then retrieve it.

Prior to Java 1.5, a new Integer object had to be created and initialized from the int before it could be added to a Vector. In order to retrieve the value, the member of the Vector had to be cast back to an Integer, and then converted back to an int.
Java (before version 1.5) 	Python

public Vector aList        = new Vector;
public int    aNumber      = 5;
public int    anotherNumber;

aList.addElement(new Integer(aNumber));
anotherNumber = ((Integer)aList.getElement(0)).intValue();

	

aList = []
aNumber = 5

aList.append(aNumber)
anotherNumber = aList[0]

This clumsiness was eliminated in Java 1.5 with the introduction of generics (which allows you to �type� a container object) and autoboxing (which automates conversion between primitive types and their corresponding wrapper classes). With generics, it is possible to code:

ContainerType<ContainedType>

which reads as:

ContainerType restricted to objects of ContainedType
Java (after version 1.5) 	Python

public Vector<Integer> aList = new Vector<Integer>;
public int    aNumber      = 5;
public int    anotherNumber;

aList.addElement(aNumber);
anotherNumber = aList.getElement(0);

	

aList = []
aNumber = 5

aList.append(aNumber)
anotherNumber = aList[0]

Example

Verbosity is not just a matter of increasing the number of characters that must be typed � it is also a matter of increasing the number of places where mistakes can be made. The Java code on the left has 5 control characters: ( ) { } ; where the corresponding Python code has only one control character, the colon. (Or two, if you count indentation. See below.)
Java 	Python

if ( a > b )
{
    a = b;
    b = c;
}

	

if  a > b :
    a = b
    b = c

Omitting or duplicating such characters is easy to do accidentally, and constitutes a severe error in the code. In my personal estimate, I spend 5 times as much time fixing such errors in Java as I do in Python. It really cuts into your productivity � and your creative energy � when you spend that much of your time just trying to satisfy the compiler.

Technically, Python has another control character that Java does not � indentation. But the requirement for correct indentation is the same in Java as it is in Python, because in both languages correct indentation is a practical requirement for human-readable code. The Python interpreter automatically enforces correct indentation, whereas the Java compiler does not. With Java, you need an add-on product such as the Jalopy code formatter to provide automated
enforcement of indentation standards.



Creating Our Zip File

Lets jump right in and create our Zip file, then add a few sample files to it.

[code]
>>> import zipfile ///Inbuilt Package
>>> zip = zipfile.ZipFile(�Python.zip�, �w�)//It will create a 							zip folder named of 								"Python.zip"
>>> zip.write(�file1.txt�)    //it will copy this file in zip
>>> zip.write(�file2.gif�)    
>>> zip.close()
[/code]

So we should have small Zip containing two files (file.txt and file.gif) sitting in our current working directory. Easy enough and pretty neat overall. How about something a little more interesting? Adding all the .txt files in a directory to our archive, perhaps?


Python os.walk() Method:


The method walk() generates the file names in a directory tree by walking the tree either top-down or bottom-up.


os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])


top -- Each directory rooted at directory, yields 3-tuples, i.e., (dirpath, dirnames, filenames)

topdown -- If optional argument topdown is True or not specified, directories are scanned from top-down. If topdown is set to False, directories are scanned from bottom-up.
'

for root, dirs, files in os.walk(".", topdown=False):
    for name in files:
        print(os.path.join(root, name))
    for name in dirs:
        print(os.path.join(root, name))



Here root will have he value of path of derectoy and subderectory
	dir will have directries
	files will have list of files



import os
import zipfile
from time import sleep

def zipdir(path, ziph):
    # ziph is zipfile handle
    for root,folders, files in os.walk(path):
        parent_folder = os.path.dirname(path)
        for folder in folders:
            absolute_path=os.path.join(root,folder)
            print("absolute path:=",absolute_path)
            relative_path = absolute_path.replace(parent_folder + '\\',
                                                      '')
            print("Relative Path:=",relative_path)
            #sleep(300000)
            print( "Adding '%s' to archive." % absolute_path )
            ziph.write(absolute_path, relative_path)
        for file_name in files:
                absolute_path = os.path.join(root, file_name)
                relative_path = absolute_path.replace(parent_folder + '\\',
                                                      '')
                print ("Adding '%s' to archive." % absolute_path)
                ziph.write(absolute_path, relative_path)
        #for file in files:
            #print(os.path.join(file))
            #print("root=",root)
            #print("dirs=",dirs)
            #print("Files=",files)
        
    
if __name__ == '__main__':
    zipf = zipfile.ZipFile('C:\\perforce_workSpace\\main\\apps\\apps-main\\testzip.zip', 'w')
    zipdir('C:\\perforce_workSpace\\main\\apps\\apps-main\\BACS4', zipf)
    zipf.close()




Parent_folder:= C:\perforce_workSpace\main\apps\apps-main
absolute path:= C:\perforce_workSpace\main\apps\apps-main\BACS4\BACSCPL
Relative Path:= BACS4\BACSCPL



What is PIP/How to install modules externally:

pip is a package management system used to install and manage software packages written in Python. Many packages can be found in the Python Package Index (PyPI).

Securely Download get-pip.py [1]
Run python get-pip.py. This will install or upgrade pip

Now you can install any package using PIP:

Go to C:\Python34\Scripts
and then fire command
ex. 

C:\Python34\Scripts>pip.exe install wheel
Collecting wheel
  Downloading wheel-0.24.0-py2.py3-none-any.whl (63kB)
    100% |################################| 65kB 315kB/s
Installing collected packages: wheel
Successfully installed wheel-0.24.0

C:\Python34\Scripts>pip.exe install twine
Collecting twine
  Downloading twine-1.5.0-py2.py3-none-any.whl
Collecting pkginfo (from twine)
  Downloading pkginfo-1.2.1.tar.gz
Requirement already satisfied (use --upgrade to upgrade): requests in c:\python34\lib\site-packages (from twine)
Installing collected packages: pkginfo, twine
  Running setup.py install for pkginfo
Successfully installed pkginfo-1.2.1 twine-1.5.0

C:\Python34\Scripts>


What is __init__.py for?What is __init__.py for?

The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable, described later.


Note: 

 Just found something rather misleading with negative indices:
>
> s = [1,2,3,4,5,6,7,8,9]
> print s, s[-3], s[-4]   # [1, 2, 3, 4, 5, 6, 7, 8, 9] 7 6
> s.insert(-3, 0)
> print s, s[-3], s[-4]   # [1, 2, 3, 4, 5, 6, 0, 7, 8, 9] 7 0
>
> So, I did insert 0 at index -3, but s[-3] is still 7, & 0 is in fact at
> index -4. Well, this can be explained: insertion adds an index, there are
> now 10, so when counting backwards a given index does not point to the same
> position/item anymore than before insertion. Still, it's a bit disturbing.
> What do you think?
> (And: should insert behave so that 0 actually is at index -3, meaning
> insert it after 7?)
>
> (No issue with positive indices, indeed.)
>

I think it may just be an issue with misunderstanding what the insert does:

>>> help(list.insert)

insert(...)
    L.insert(index, object) -- insert object before index

When you insert(-3, 0) you are inserting 0 before index -3. When it says
"before" it has nothing to do with the direction of travel.


9.9. Iterators

Note : python 2.x has method called next() while python 3.x has method __next__()

By now you have probably noticed that most container objects can be looped over using a for statement:

for element in [1, 2, 3]:
    print element
for element in (1, 2, 3):
    print element
for key in {'one':1, 'two':2}:
    print key
for char in "123":
    print char
for line in open("myfile.txt"):
    print line,
This style of access is clear, concise, and convenient. The use of iterators pervades and unifies Python. Behind the scenes, the for statement calls iter() on the container object. The function returns an iterator object that defines the method next() which accesses elements in the container one at a time. When there are no more elements, next() raises a StopIteration exception which tells the for loop to terminate. This example shows how it all works:

>>>
>>> s = 'abc'
>>> it = iter(s)
>>> it
<iterator object at 0x00A1DB50>
>>> it.next()
'a'
>>> it.next()
'b'
>>> it.next()
'c'
>>> it.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
    it.next()
StopIteration
Having seen the mechanics behind the iterator protocol, it is easy to add iterator behavior to your classes. Define an __iter__() method which returns an object with a next() method. If the class defines next(), then __iter__() can just return self:

class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
>>>
>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
...     print char
...
m
a
p
s




9.10. Generators


Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). An example shows that generators can be trivially easy to create:

def reverse(data):
    for index in range(len(data)-1, -1, -1):
        yield data[index]
>>>
>>> for char in reverse('golf'):
...     print char
...
f
l
o
g
Anything that can be done with generators can also be done with class-based iterators as described in the previous section. What makes generators so compact is that the __iter__() and next() methods are created automatically.

Another key feature is that the local variables and execution state are automatically saved between calls. This made the function easier to write and much more clear than an approach using instance variables like self.index and self.data.

In addition to automatic method creation and saving program state, when generators terminate, they automatically raise StopIteration. In combination, these features make it easy to create iterators with no more effort than writing a regular function.


5.1.1. Using Lists as Stacks
The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (�last-in, first-out�). To add an item to the top of the stack, use append(). To retrieve an item from the top of the stack, use pop() without an explicit index. For example:

>>>
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
5.1.2. Using Lists as Queues
It is also possible to use a list as a queue, where the first element added is the first element retrieved (�first-in, first-out�); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one).

To implement a queue, use collections.deque which was designed to have fast appends and pops from both ends. For example:

>>>
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry")           # Terry arrives
>>> queue.append("Graham")          # Graham arrives
>>> queue.popleft()                 # The first to arrive now leaves
'Eric'
>>> queue.popleft()                 # The second to arrive now leaves
'John'
>>> queue                           # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])



Python Interview Questions:
A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py

1. What is Python? State some programming language features of Python.

    Python is a modern powerful interpreted language with objects, modules, threads, exceptions, and automatic memory managements.
    Python was introduced to the world in the year 1991 by Guido van Rossum
    Salient features of Python are
    -Simple & Easy: Python is simple language & easy to learn.
    -Free/open source: it means everybody can use python without purchasing license.
    -High level language: when coding in Python one need not worry about low-level details.
    -Portable: Python codes are Machine & platform independent.
    -Extensible: Python program supports usage of C/ C++ codes.
    -Embeddable Language: Python code can be embedded within C/C++ codes & can be used a scripting language.
    -Standard Library: Python standard library contains prewritten tools for programming.
    -Build-in Data Structure: contains lots of data structure like lists, numbers & dictionaries.

2. What are the rules for local and global variables in Python?

If a variable is defined outside function then it is implicitly global. If variable is assigned new value inside the function means it is local. If we want to make it global we need to explicitly define it as global. Variable referenced inside the function are implicit global. 

3.How do we share global variables across modules in Python?

    We can create a config file & store the entire global variable to be shared across modules or script in it. By simply importing config, the entire global variable defined it will be available for use in other modules.

4.How can we pass optional or keyword parameters from one function to another in Python?

Gather the arguments using the * and ** specifiers in the function's parameter list. This gives us positional arguments as a tuple and the keyword arguments as a dictionary. Then we can pass these arguments while calling another function by using * and **:

def fun1(a, *tup, **keywordArg):

5.What is a Lambda form? Explain about assert statement?

The lambda form:

    Using lambda keyword tiny anonymous functions can be created.
    It is a very powerful feature of Python which declares a one-line unknown small function on the fly. The lambda is used to create new function objects and then return them at runtime.
    The general format for lambda form is:
    lambda parameter(s): expression using the parameter(s)
    For instance k is lambda function-
    >>> k= lambda y: y + y
    >>> k(30)
    60
    >>> k(40)
    80
     

The assert statement:

    The build-in assert statement of python introduced in version 1.5 is used to assert that something is true.
    Programmers often place assertions at the beginning of a function to check for valid input, and after function call to check for valid output. Assert statement can be removed after testing of program is over.
    If assert evaluates to be false, an AssertionError exception is raised. AssertionError exceptions can be handled with the try-except statement.
    The general syntax for assert statement is:
    assert Expression[, Arguments]


Python: Lambda Functions
Note: Lines beginning with ">>>" and "..." indicate input to Python (these are the default prompts of the interactive interpreter). Everything else is output from Python.

Python supports the creation of anonymous functions (i.e. functions that are not bound to a name) at runtime, using a construct called "lambda". This is not exactly the same as lambda in functional programming languages, but it is a very powerful concept that's well integrated into Python and is often used in conjunction with typical functional concepts like filter(), map() and reduce().

This piece of code shows the difference between a normal function definition ("f") and a lambda function ("g"):
	>>> def f (x): return x**2
... 
>>> print f(8)
64
>>> 
>>> g = lambda x: x**2
>>> 
>>> print g(8)
64

As you can see, f() and g() do exactly the same and can be used in the same ways. Note that the lambda definition does not include a "return" statement -- it always contains an expression which is returned. Also note that you can put a lambda definition anywhere a function is expected, and you don't have to assign it to a variable at all.

The following code fragments demonstrate the use of lambda functions. Note that you should have Python 2.2 or newer, in order to have support for nested scopes (in older versions you have to pass "n" through a default argument to make this example work).
	>>> def make_incrementor (n): return lambda x: x + n
>>> 
>>> f = make_incrementor(2)
>>> g = make_incrementor(6)
>>> 
>>> print f(42), g(42)
44 48
>>> 
>>> print make_incrementor(22)(33)
55

The above code defines a function "make_inrementor" that creates an anonymous function on the fly and returns it. The returned function increments its argument by the value that was specified when it was created.

You can now create multiple different incrementor functions and assign them to variables, then use them independent from each other. As the last statement demonstrates, you don't even have to assign the function anywhere -- you can just use it instantly and forget it when it's not needed anymore.

The following takes this a step further.
	>>> foo = [2, 18, 9, 22, 17, 24, 8, 12, 27]
>>> 
>>> print filter(lambda x: x % 3 == 0, foo)
[18, 9, 24, 12, 27]
>>> 
>>> print map(lambda x: x * 2 + 10, foo)
[14, 46, 28, 54, 44, 58, 26, 34, 64]
>>> 
>>> print reduce(lambda x, y: x + y, foo)
139

First we define a simple list of integer values, then we use the standard functions filter(), map() and reduce() to do various things with that list. All of the three functions expect two arguments: A function and a list.

Of course, we could define a separate function somewhere else and then use that function's name as an argument to filter() etc., and in fact that's probably a good idea if we're going to use that function several times, or if the function is too complex for writing in a single line. However, if we need it only once and it's quite simple (i.e. it contains just one expression, like in the above examples), it's more convenient to use a lambda construct to generate a (temporary) anonymous function and pass it to filter() immediately. This creates very compact, yet readable code.

In the first example, filter() calls our lambda function for each element of the list, and returns a new list that contains only those elements for which the function returned "True". In this case, we get a list of all elements that are multiples of 3. The expression x % 3 == 0 computes the remainder of x divided by 3 and compares the result with 0 (which is true if x is evenly divisible by 3).

In the second example, map() is used to convert our list. The given function is called for every element in the original list, and a new list is created which contains the return values from our lambda function. In this case, it computes 2 * x + 10 for every element.

Finally, reduce() is somewhat special. The "worker function" for this one must accept two arguments (we've called them x and y here), not just one. The function is called with the first two elements from the list, then with the result of that call and the third element, and so on, until all of the list elements have been handled. This means that our function is called n-1 times if the list contains n elements. The return value of the last call is the result of the reduce() construct. In the above example, it simply adds the arguments, so we get the sum of all elements. (Note: since Python 2.3 there's a built-in function sum()that does the same thing more efficiently.)

The following example is one way to compute prime numbers in Python (not the most efficient one, though):
	>>> nums = range(2, 50) 
>>> for i in range(2, 8): 
...     nums = filter(lambda x: x == i or x % i, nums)
... 
>>> print nums
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]

How does it work? First, we put all numbers from 2 to 49 into a list called "nums". Then we have a "for" loop that iterates over all possible divisors, i.e. the value of "i" goes from 2 to 7. Naturally, all numbers that are multiples of those divisors cannot be prime numbers, so we use a filter function to remove them from the list. (This algorithm is called "the sieve of Eratosthenes".)

In the above case, the filter function simply says: "Leave the element in the list if it is equal to i, or if it leaves a non-zero remainder when divided by i. Otherwise remove it from the list." After the filtering loop finishes, only prime numbers are left, of course. I am not aware of a language in which you can do the same thing with built-in features as compact and as readable as in Python (except for functional programming languages).

Note: The range function simply returns a list containing the numbers from x to y-1. For example, range(5, 10) returns the list [5, 6, 7, 8, 9].

In the following example, a sentence is split up into a list of words, then a list is created that contains the length of each word.
	>>> sentence = 'It is raining cats and dogs'
>>> words = sentence.split()
>>> print words
['It', 'is', 'raining', 'cats', 'and', 'dogs']
>>> 
>>> lengths = map(lambda word: len(word), words)
>>> print lengths
[2, 2, 7, 4, 3, 4]

I think it doesn't need any further explanation, the code is practically self-documenting.

Of course, it could all be written in one single statement. Admittedly, this is somewhat less readable (not much, though).
	>>> print map(lambda w: len(w), 'It is raining cats and dogs'.split())
[2, 2, 7, 4, 3, 4]

Here's an example from the UNIX scripting world: We want to find all mount points in our file system. To do that, we execute the external "mount" command and parse the output.
	>>> import commands
>>> 
>>> mount = commands.getoutput('mount -v')
>>> lines = mount.splitlines()
>>> points = map(lambda line: line.split()[2], lines)
>>> 
>>> print points
['/', '/var', '/usr', '/usr/local', '/tmp', '/proc']

The getoutput function from the commands module (which is part of the Python standard library) runs the given command and returns its output as a single string. Therefore, we split it up into separate lines first. Finally we use "map" with a lambda function that splits each line (on whitespace, which is the default) and returns just the third element of the result, which is the mountpoint.

Again, we could write all of that in one single statement, which increases compactness but reduces readability:
	print map(lambda x: x.split()[2], commands.getoutput('mount -v').splitlines())
['/', '/var', '/usr', '/usr/local', '/tmp', '/proc']

When writing "real-world" scripts, it is recommended to split up complex statements so that it is easier to see what it does. Also, it is easier to make changes.

However, the task of splitting up the output of a command into a list of lines is very common. You need it all the time when parsing the output of external commands. Therefore, it is common practice to include the split operation on the getoutput line, but do the rest separately. This is a good trade-off between compactness and readability:
	>>> lines = commands.getoutput('mount -v').splitlines()
>>> 
>>> points = map(lambda line: line.split()[2], lines)
>>> print points
['/', '/var', '/usr', '/usr/local', '/tmp', '/proc']

An even better idea is probably to write a small function for that task, which encapsulates the job of running the command and splitting the output.

On a related note, you can also use so-called list comprehensions to construct lists from other lists. Sometimes this is preferable because of efficiency or readability. The previous example could very well be rewritten using a list comprehension:
	>>> lines = commands.getoutput('mount -v').splitlines()
>>> 
>>> points = [line.split()[2] for line in lines]
>>> print points
['/', '/var', '/usr', '/usr/local', '/tmp', '/proc']

In many cases, you can use list comprehensions instead of map() or filter(). It depends on the situation which one should be preferred.

Note: The commands module is deprecated in newer versions of Python (though it still works in all 2.x versions). Instead, the subprocess module should be used which is available since Python 2.4. The commands.getoutput() function can be replaced by subprocess.check_output(). Please refer to the documentation for details.



6.Explain the role of repr function.

    Python can convert any value to a string by making use of two functions repr() or str().
    The str() function returns representations of values which are human-readable, while repr() generates representations which can be read by the interpreter.
    repr() returns a machine-readable representation of values, suitable for an exec command.
    Following code sniipets shows working of repr() & str() :

def fun():
y=2333.3
x=str(y)
z=repr(y)
print " y :",y
print "str(y) :",x
print "repr(y):",z
fun()
-------------
output
y : 2333.3
str(y) : 2333.3
repr(y) : 2333.3000000000002 



  
7.How is memory managed in python?

    Memory management in Python involves a private heap containing all Python objects and data structures. Interpreter takes care of Python heap and that the programmer has no access to it.
    The allocation of heap space for Python objects is done by Python memory manager. The core API of Python provides some tools for the programmer to code reliable and more robust program.
    Python also has a build-in garbage collector which recycles all the unused memory. When an object is no longer referenced by the program, the heap space it occupies can be freed. The garbage collector determines objects which are no longer referenced by the sprogram frees the occupied memory and make it available to the heap space.
    The gc module defines functions to enable /disable garbage collector:
    gc.enable() -Enables automatic garbage collection.
    gc.disable() - Disables automatic garbage collection.


8.How can I find the methods or attributes of an object in python?

    Built-in dir() function of Python ,on an instance shows the instance variables as well as the methods and class attributes defined by the instance's class and all its base classes alphabetically. So by any object as argument to dir() we can find all the methods & attributes of the object�s class.
    Following code snippet shows dir() at work :
    class Employee:
    def __init__(self,name,empCode,pay):
    self.name=name
    self.empCode=empCode
    self.pay=pay

    print("dir() listing all the Methods & attributes of class Employee")
    print dir(e)
    -----------------------------------------------------
    Output
    dir() listing all the Methods & attributes of class Employee
    [ '__init__', 'empCode', 'name', 'pay']

9.How do you make an array in Python?

    The array module contains methods for creating arrays of fixed types with homogeneous data types. Arrays are slower then list.
    Array of characters, integers, floating point numbers can be created using array module.
    array(typecode[, intializer])
    Returns a new array whose items are constrained by typecode, and initialized from the optional initialized value. Where the typecode can be for instance �c� for character value, �d� for double, �f� for float.
array('l')
array('c', 'hello world')
array('u', u'hello \u2641')
array('l', [1, 2, 3, 4, 5])
array('d', [1.0, 2.0, 3.14])


import array

a = array.array('i', xrange(5))
print 'Initial :', a

a.extend(xrange(5))
print 'Extended:', a

print 'Slice   :', a[3:6]

print 'Iterator:', list(enumerate(a))
$ python array_sequence.py

Initial : array('i', [0, 1, 2, 3, 4])
Extended: array('i', [0, 1, 2, 3, 4, 0, 1, 2, 3, 4])
Slice   : array('i', [3, 4, 0])
Iterator: [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (5, 0), (6, 1), (7, 2), (8, 3), (9, 4)]

10.Explain how to create a multidimensional list.

    There are two ways in which Multidimensional list can be created:
    By direct initializing the list as shown below to create multidimlist below
    >>>multidimlist = [ [227, 122, 223],[222, 321, 192],[21, 122, 444]]
    >>>print multidimlist[0]
    >>>print multidimlist[1][2]
    __________________________
    Output
    [227, 122, 223]
    192
    The second approach is to create a list of the desired length first and then fill in each element with a newly created lists demonstrated below :
    >>>list=[0]*3
    >>>for i in range(3):
    >>> list[i]=[0]*2
    >>>for i in range (3):
    >>> for j in range(2):
    >>> list[i][j] = i+j
    >>>print list
    __________________________
    Output
    [[0, 1], [1, 2], [2, 3]
11. Disadvantages of Python are:

    Python isn't the best for memory intensive tasks.
    Python is interpreted language & is slow compared to C/C++ or java.
    Python not a great choice for a high-graphic 3d game that takes up a lot of CPU.
    Python is evolving continuously, with constant evolution there is little substantial documentation available for the language.

12. Explain how to copy an object in Python.

    There are two ways in which objects can be copied in python.
    Shallow copy & Deep copy.
    Shallow copies duplicate as minute as possible whereas Deep copies duplicate everything.
    If a is object to be copied then
    -copy.copy(a) returns a shallow copy of a.
    -copy.deepcopy(a) returns a deep copy of a
13. What are the ways to write a function using call by reference?

Arguments in python are passed as an assignment. This assignment creates an object that has no relationship between an argument name in source and target. The procedure to write the function using call by reference includes:
The tuple result can be returned to the object which called it. The example below shows it:

def function(a, b):
a = 'value'
b = b + 1
# a and b are local variables that are used to assign the new objects
return a, b
# This is the function that is used to return the value stored in b

� The use of global variables allows the function to be called as reference but this is not the safe method to call any function.
� The use of mutable (they are the classes that consists of changeable objects) objects are used to pass the function by reference.

def function(a):
a[0] = 'string'
a[1] = a[1] + 1
# The �a� array give reference to the mutable list and it changes the changes that are shared
args = ['string', 10]
func1(args)
print args[0], args[1]
#This prints the value stored in the array of �a�
14. What are the commands that are used to copy an object in Python?

The command that is used to copy an object in python includes:
� copy.copy() function: This makes a copy of the file from source to destination. It returns a shallow copy of the parameter that is passed.
� copy.deepcopy(): This also creates a copy of the object from source to destination. It returns a deep copy of the parameter that is passed to the function.
The dictionary consists of all the objects and the copy() method which is used as:
newdict = olddict.copy()
The assignment statement doesn�t copy any object but it creates a binding between the target and the object that is used for the mutable items. Copy is required to keep a copy of it using the modules that is provided to give generic and shallow operations.
15. What is the difference between deep and shallow copy?

� Shallow copy is used when a new instance type gets created and it keeps the values that are copied in the new instance. Whereas, deep copy is used to store the values that are already copied.
� Shallow copy is used to copy the reference pointers just like it copies the values. These references point to the original objects and the changes made in any member of the class will also affect the original copy of it. Whereas, deep copy doesn�t copy the reference pointers to the objects. Deep copy makes the reference to an object and the new object that is pointed by some other object gets stored. The changes made in the original copy won�t affect any other copy that uses the object.
� Shallow copy allows faster execution of the program and it depends on the size of the data that is used. Whereas, deep copy makes it slower due to making certain copies for each object that is been called. 


16. Write a program to check whether the object is of a class or its subclass.

There is a method which is built-in to show the instances of an object that consists of many classes by providing a tuple in a table instead of individual classes. The method is given as isinstance(obj,cls) and in more details given as:

isinstance(obj, (class1, class2, ...)) that is used to check about the object�s presence in one of the classes. The built in types can also have many formats of the same function like isinstance(obj, str) or isinstance(obj, (int, long, float, complex)).

It is not preferred to use the class instead user-defined classes are made that allow easy object-oriented style to define the behavior of the object�s class. These perform different thing that is based on the class. The function differs from one class to another class. To find out the object of the particular class the following program is used:

def search(obj):
if isinstance(obj, box):
# This is the code that is given for the box and write the program in the object
elif isinstance(obj, Document):
# This is the code that searches the document and writes the values in it
elif
obj.search()
#This is the function used to search the object�s class.
1. How would you setup many projects where each one uses different versions and third party libraries??
=> 



PYTHON DJANGO:

Download Django-1.8.2.tar.gz from the internet 
Extract it using 7-zip




pip vs easy_install:-

easy_install was released in 2004, as part of setuptools. It was notable at the time for installing packages from PyPI using requirement specifiers, and automatically installing dependencies.

pip came later in 2008, as alternative to easy_install, although still largely built on top of setuptools components. It was notable at the time for not installing packages as Eggs or from Eggs (but rather simply as �flat� packages from sdists), and introducing the idea of Requirements Files, which gave users the power to easily replicate environments.

Here�s a breakdown of the important differences between pip and easy_install now:

 				pip	easy_install
Installs from Wheels	Yes	No
Uninstall Packages	Yes (pip uninstall)	No
Dependency Overrides	Yes (Requirements Files)	No
List Installed Packages	Yes (pip list and pip freeze)	No
PEP438 Support	Yes	No
Installation format	�Flat� packages with egg-info metadata.	Encapsulated Egg format
sys.path modification	No	Yes
Installs from Eggs	No	Yes
pylauncher support	No	Yes [1]
Multi-version Installs	No	Yes





IMP Interview Questions:
1. 

def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')

print "list1 = %s" % list1
print "list2 = %s" % list2
print "list3 = %s" % list3
How would you modify the definition of extendList to produce the presumably desired behavior?
 
The output of the above code will be:

list1 = [10, 'a']
list2 = [123]
list3 = [10, 'a']

Many will mistakenly expect list1 to be equal to [10] and list3 to be equal to ['a'], thinking that the list argument will be set to its default value of [] each time extendList is called.

However, what actually happens is that the new default list is created only once when the function is defined, and that same list is then used subsequently whenever extendList is invoked without a list argument being specified. This is because expressions in default arguments are calculated when the function is defined, not when it�s called.

list1 and list3 are therefore operating on the same default list, whereas list2 is operating on a separate list that it created (by passing its own empty list as the value for the list parameter)




Why is tuple faster than list?




The reported "speed of construction" ratio only holds for constant tuples (ones whose items are expressed by literals). Observe carefully (and repeat on your machine -- you just need to type the commands at a shell/command window!)...:

$ python3.1 -mtimeit -s'x,y,z=1,2,3' '[x,y,z]'
1000000 loops, best of 3: 0.379 usec per loop
$ python3.1 -mtimeit '[1,2,3]'
1000000 loops, best of 3: 0.413 usec per loop

$ python3.1 -mtimeit -s'x,y,z=1,2,3' '(x,y,z)'
10000000 loops, best of 3: 0.174 usec per loop
$ python3.1 -mtimeit '(1,2,3)'
10000000 loops, best of 3: 0.0602 usec per loop

$ python2.6 -mtimeit -s'x,y,z=1,2,3' '[x,y,z]'
1000000 loops, best of 3: 0.352 usec per loop
$ python2.6 -mtimeit '[1,2,3]'
1000000 loops, best of 3: 0.358 usec per loop

$ python2.6 -mtimeit -s'x,y,z=1,2,3' '(x,y,z)'
10000000 loops, best of 3: 0.157 usec per loop
$ python2.6 -mtimeit '(1,2,3)'
10000000 loops, best of 3: 0.0527 usec per loop

I didn't do the measurements on 3.0 because of course I don't have it around -- it's totally obsolete and there is absolutely no reason to keep it around, since 3.1 is superior to it in every way (Python 2.7, if you can upgrade to it, measures as being almost 20% faster than 2.6 in each task -- and 2.6, as you see, is faster than 3.1 -- so, if you care seriously about performance, Python 2.7 is really the only release you should be going for!).

Anyway, the key point here is that, in each Python release, building a list out of constant literals is about the same speed, or slightly slower, than building it out of values referenced by variables; but tuples behave very differently -- building a tuple out of constant literals is typically three times as fast as building it out of values referenced by variables! You may wonder how this can be, right?-)

Answer: a tuple made out of constant literals can easily be identified by the Python compiler as being one, immutable constant literal itself: so it's essentially built just once, when the compiler turns the source into bytecodes, and stashed away in the "constants table" of the relevant function or module. When those bytecodes execute, they just need to recover the pre-built constant tuple -- hey presto!-)

This easy optimization cannot be applied to lists, because a list is a mutable object, so it's crucial that, if the same expression such as [1, 2, 3] executes twice (in a loop -- the timeit module makes the loop on your behalf;-), a fresh new list object is constructed anew each time -- and that construction (like the construction of a tuple when the compiler cannot trivially identify it as a compile-time constant and immutable object) does take a little while.

That being said, tuple construction (when both constructions actually have to occur) still is about twice as fast as list construction -- and that discrepancy can be explained by the tuple's sheer simplicity, which other answers have mentioned repeatedly. But, that simplicity does not account for a speedup of six times or more, as you observe if you only compare the construction of lists and tuples with simple constant literals as their items!_)




5. Iterators & Generators
5.1. Iterators
We use for statement for looping over a list.

>>> for i in [1, 2, 3, 4]:
...     print i,
...
1
2
3
4
If we use it with a string, it loops over its characters.

>>> for c in "python":
...     print c
...
p
y
t
h
o
n
If we use it with a dictionary, it loops over its keys.

>>> for k in {"x": 1, "y": 2}:
...     print k
...
y
x
If we use it with a file, it loops over lines of the file.

>>> for line in open("a.txt"):
...     print line,
...
first line
second line
So there are many types of objects which can be used with a for loop. These are called iterable objects.

There are many functions which consume these iterables.

>>> ",".join(["a", "b", "c"])
'a,b,c'
>>> ",".join({"x": 1, "y": 2})
'y,x'
>>> list("python")
['p', 'y', 't', 'h', 'o', 'n']
>>> list({"x": 1, "y": 2})
['y', 'x']


5.1.1. The Iteraton Protocol
The built-in function iter takes an iterable object and returns an iterator.

>>> x = iter([1, 2, 3])
>>> x
<listiterator object at 0x1004ca850>
>>> x.next()
1
>>> x.next()
2
>>> x.next()
3
>>> x.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
Each time we call the next method on the iterator gives us the next element. If there are no more elements, it raises a StopIteration.

Iterators are implemented as classes. Here is an iterator that works like built-in xrange function.

class yrange:
    def __init__(self, n):
        self.i = 0
        self.n = n

    def __iter__(self):
        return self

    def next(self):
        if self.i < self.n:
            i = self.i
            self.i += 1
            return i
        else:
            raise StopIteration()
The __iter__ method is what makes an object iterable. Behind the scenes, the iter function calls __iter__ method on the given object.

The return value of __iter__ is an iterator. It should have a next method and raise StopIteration when there are no more elements.

Lets try it out:

>>> y = yrange(3)
>>> y.next()
0
>>> y.next()
1
>>> y.next()
2
>>> y.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 14, in next
StopIteration
Many built-in functions accept iterators as arguments.

>>> list(yrange(5))
[0, 1, 2, 3, 4]
>>> sum(yrange(5))
10
In the above case, both the iterable and iterator are the same object. Notice that the __iter__ method returned self. It need not be the case always.

class zrange:
    def __init__(self, n):
        self.n = n

    def __iter__(self):
        return zrange_iter(self.n)

class zrange_iter:
    def __init__(self, n):
        self.i = 0
        self.n = n

    def __iter__(self):
        # Iterators are iterables too.
        # Adding this functions to make them so.
        return self

    def next(self):
        if self.i < self.n:
            i = self.i
            self.i += 1
            return i
        else:
            raise StopIteration()
If both iteratable and iterator are the same object, it is consumed in a single iteration.

>>> y = yrange(5)
>>> list(y)
[0, 1, 2, 3, 4]
>>> list(y)
[]
>>> z = zrange(5)
>>> list(z)
[0, 1, 2, 3, 4]
>>> list(z)
[0, 1, 2, 3, 4]
Problem 1: Write an iterator class reverse_iter, that takes a list and iterates it from the reverse direction. ::

>>> it = reverse_iter([1, 2, 3, 4])
>>> it.next()
4
>>> it.next()
3
>>> it.next()
2
>>> it.next()
1
>>> it.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
5.2. Generators
Generators simplifies creation of iterators. A generator is a function that produces a sequence of results instead of a single value.

def yrange(n):
    i = 0
    while i < n:
        yield i
        i += 1
Each time the yield statement is executed the function generates a new value.

>>> y = yrange(3)
>>> y
<generator object yrange at 0x401f30>
>>> y.next()
0
>>> y.next()
1
>>> y.next()
2
>>> y.next()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
So a generator is also an iterator. You don�t have to worry about the iterator protocol.

The word �generator� is confusingly used to mean both the function that generates and what it generates. In this chapter, I�ll use the word �generator� to mean the genearted object and �generator function� to mean the function that generates it.

Can you think about how it is working internally?

When a generator function is called, it returns an generator object without even beginning execution of the function. When next` method is called for the first time, the function starts executing until it reaches yield statement. The yielded value is returned by the next call.

The following example demonstrates the interplay between yield and call to next method on generator object.

>>> def foo():
...     print "begin"
...     for i in range(3):
...         print "before yield", i
...         yield i
...         print "after yield", i
...     print "end"
...
>>> f = foo()
>>> f.next()
begin
before yield 0
0
>>> f.next()
after yield 0
before yield 1
1
>>> f.next()
after yield 1
before yield 2
2
>>> f.next()
after yield 2
end
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>>
Lets see an example:

def integers():
    """Infinite sequence of integers."""
    i = 1
    while True:
        yield i
        i = i + 1

def squares():
    for i in integers():
        yield i * i

def take(n, seq):
    """Returns first n values from the given sequence."""
    seq = iter(seq)
    result = []
    try:
        for i in range(n):
            result.append(seq.next())
    except StopIteration:
        pass
    return result

print take(5, squares()) # prints [1, 4, 9, 16, 25]



5.3. Generator Expressions
Generator Expressions are generator version of list comprehensions. They look like list comprehensions, but returns a generator back instead of a list.

>>> a = (x*x for x in range(10))
>>> a
<generator object <genexpr> at 0x401f08>
>>> sum(a)
285
We can use the generator expressions as arguments to various functions that consume iterators.

>>> sum(((x*x for x in range(10)))
285
When there is only one argument to the calling function, the parenthesis around generator expression can be omitted.

>>> sum(x*x for x in range(10))
285
Another fun example:

Lets say we want to find first 10 (or any n) pythogorian triplets. A triplet (x, y, z) is called pythogorian triplet if x*x + y*y == z*z.

It is easy to solve this problem if we know till what value of z to test for. But we want to find first n pythogorian triplets.

>>> pyt = ((x, y, z) for z in integers() for y in xrange(1, z) for x in range(1, y) if x*x + y*y == z*z)
>>> take(10, pyt)
[(3, 4, 5), (6, 8, 10), (5, 12, 13), (9, 12, 15), (8, 15, 17), (12, 16, 20), (15, 20, 25), (7, 24, 25), (10, 24, 26), (20, 21, 29)]


5.3.1. Example: Reading multiple files
Lets say we want to write a program that takes a list of filenames as arguments and prints contents of all those files, like cat command in unix.

The traditional way to implement it is:

def cat(filenames):
    for f in filenames:
        for line in open(f):
            print line,
Now, lets say we want to print only the line which has a particular substring, like grep command in unix.

def grep(pattern, filenames):
    for f in filenames:
        for line in open(f):
            if pattern in line:
                print line,
Both these programs have lot of code in common. It is hard to move the common part to a function. But with generators makes it possible to do it.

def readfiles(filenames):
    for f in filenames:
        for line in open(f):
            yield line

def grep(pattern, lines):
    return (line for line in lines if pattern in lines)

def printlines(lines):
    for line in lines:
        print line,

def main(pattern, filenames):
    lines = readfiles(filenames)
    lines = grep(pattern, lines)
    printlines(lines)
The code is much simpler now with each function doing one small thing. We can move all these functions into a separate module and reuse it in other programs.

Problem 2: Write a program that takes one or more filenames as arguments and prints all the lines which are longer than 40 characters.

Problem 3: Write a function findfiles that recursively descends the directory tree for the specified directory and generates paths of all the files in the tree.

Problem 4: Write a function to compute the number of python files (.py extension) in a specified directory recursively.

Problem 5: Write a function to compute the total number of lines of code in all python files in the specified directory recursively.

Problem 6: Write a function to compute the total number of lines of code, ignoring empty and comment lines, in all python files in the specified directory recursively.

Problem 7: Write a program split.py, that takes an integer n and a filename as command line arguments and splits the file into multiple small files with each having n lines.

5.4. Itertools
The itertools module in the standard library provides lot of intersting tools to work with iterators.

Lets look at some of the interesting functions.

chain � chains multiple iterators together.

>>> it1 = iter([1, 2, 3])
>>> it2 = iter([4, 5, 6])
>>> itertools.chain(it1, it2)
[1, 2, 3, 4, 5, 6]
izip � iterable version of zip

>>> for x, y in itertools.izip(["a", "b", "c"], [1, 2, 3]):
...     print x, y
...
a 1
b 2
c 3
Problem 8: Write a function peep, that takes an iterator as argument and returns the first element and an equivalant iterator.

>>> it = iter(range(5))
>>> x, it1 = peep(it)
>>> print x, list(it1)
0 [0, 1, 2, 3, 4]
Problem 9: The built-in function enumerate takes an iteratable and returns an iterator over pairs (index, value) for each value in the source.

>>> list(enumerate(["a", "b", "c"])
[(0, "a"), (1, "b"), (2, "c")]
>>> for i, c in enumerate(["a", "b", "c"]):
...     print i, c
...
0 a
1 b
2 c
Write a function my_enumerate that works like enumerate.

Problem 10: Implement a function izip that works like itertools.izip.





Q . I'd like to rotate a Python list by an arbitrary number of items to the right or left

Two ways to do this:

1. If applicable, you could use collections.deque as a solution:

import collections

d = collections.deque([1,2,3,4,5])
d.rotate(3)

print d
>>> deque([3, 4, 5, 1, 2])

2. def rotate(l,n):
    return l[-n:] + l[:-n]





Shallow and deep copies in Python




The difference between shallow and deep copying is only relevant for compound objects, i.e. objects containing other objects, like lists or class instances. Python creates real copies only if it has to, i.e. if the user, the programmer, explicitly demands it. 

Examples below show that crucial problems can occur when copying mutable objects, i.e. when copying lists and dictionaries.


>>> list1=[1,2,3,4]
>>> list2=list1[:]
>>> list2[0]=9
>>> list1
[1, 2, 3, 4]
1
2
3
4
5
>>> list1=[1,2,3,4]
>>> list2=list1[:]  -->> remember '[:]' this , very IMP
>>> list2[0]=9
>>> list1
[1, 2, 3, 4]



As can be seen, list2 is a shallow copy of list1, and changes with elements in list2 is isopated to list1.



However, shallow copy will have trouble when list1 contains sublist


>>> list1=[1,2,[3,4]]
>>> list2=list1[:]
>>> list2[0]=9
>>> list1
[1, 2, [3, 4]]
>>> list2[2][0]=99
>>> list2
[9, 2, [99, 4]]
>>> list1
[1, 2, [99, 4]]
1
2
3
4
5
6
7
8
9
10
>>> list1=[1,2,[3,4]]
>>> list2=list1[:]
>>> list2[0]=9
>>> list1
 [1, 2, [3, 4]]
>>> list2[2][0]=99
>>> list2
 [9, 2, [99, 4]]
>>> list1
 [1, 2, [99, 4]]
As can be seen, even thouth change of list2[0] does not propagate to list1, the change of list2[2][0] does chage list1. In other words, since the list contains sublist, the shallow copy does not isolate changes of list1 and list2.

A solution to this problem is to use the deepcopy function from the copy module.


>>> import copy as cp
>>> list1=[1,2,[3,4]]
>>> list2=cp.deepcopy(list1)
>>> list2[2][0]=99
>>> list2
Out[12]: [1, 2, [99, 4]]
>>> list1
Out[13]: [1, 2, [3, 4]]
1
2
3
4
5
6
7
8
>>> import copy as cp
>>> list1=[1,2,[3,4]]
>>> list2=cp.deepcopy(list1)
>>> list2[2][0]=99
>>> list2
Out[12]: [1, 2, [99, 4]]
>>> list1
Out[13]: [1, 2, [3, 4]]





Default Argument Values
The most useful form is to specify a default value for one or more arguments. This creates a function that can be called with fewer arguments than it is defined to allow. For example:

def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
    while True:
        ok = raw_input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nop', 'nope'):
            return False
        retries = retries - 1
        if retries < 0:
            raise IOError('refusenik user')
        print complaint
This function can be called in several ways:

giving only the mandatory argument: ask_ok('Do you really want to quit?')
giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2)
or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')
This example also introduces the in keyword. This tests whether or not a sequence contains a certain value.

The default values are evaluated at the point of function definition in the defining scope, so that

i = 5

def f(arg=i):
    print arg

i = 6
f()
will print 5.

Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls:

def f(a, L=[]):
    L.append(a)
    return L

print f(1)
print f(2)
print f(3)
This will print

[1]
[1, 2]
[1, 2, 3]
If you don�t want the default to be shared between subsequent calls, you can write the function like this instead:

def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L



Michigan State University
Search Tool 
Search...
Search Button
Spartan Ideas
A collection of thoughts, ideas, and opinions independently written by members of the MSU community and curated by MSU Libraries
The key differences between Python 2.7.x and Python 3.x with examples
Written by: Sebastian Raschka

Primary Source: Sebastian Raschka

Many beginning Python users are wondering with which version of Python they should start. My answer to this question is usually something along the lines �just go with the version your favorite tutorial was written in, and check out the differences later on.� 

But what if you are starting a new project and have the choice to pick? In my opinion, there is no �right� or �wrong� as long as both Python 2.7.x and Python 3.x support the libraries that you are planning to use. However, it is worthwhile to have a look at the major differences between those two most popular versions of Python to avoid common pitfalls when writing the code for either one of them, or if you are planning to port your project.

Sections
Using the __future__ module
The print function
Integer division
Unicode
xrange
Raising exceptions
Handling exceptions
The next() function and .next() method
For-loop variables and the global namespace leak
Comparing unorderable types
Parsing user inputs via input()
Returning iterable objects instead of lists
More articles about Python 2 and Python 3
An IPython Notebook for this article can be found here

Input code will be shown with Python syntax highlighting,
and the output after execution in blue.

 

The __future__ module

Python 3.x introduced some Python 2-incompatible keywords and features that can be imported via the in-built __future__ module in Python 2. It is recommended to use __future__ imports it if you are planning Python 3.x support for your code. For example, if we want Python 3.x�s integer division behavior in Python 2, we can import it via

from __future__ import division
More features that can be imported from the __future__ module are listed in the table below:

feature	optional in	mandatory in	effect
nested_scopes	2.1.0b1	2.2	PEP 227: Statically Nested Scopes
generators	2.2.0a1	2.3	PEP 255: Simple Generators
division	2.2.0a2	3.0	PEP 238: Changing the Division Operator
absolute_import	2.5.0a1	3.0	PEP 328: Imports: Multi-Line and Absolute/Relative
with_statement	2.5.0a1	2.6	PEP 343: The �with� Statement
print_function	2.6.0a2	3.0	PEP 3105: Make print a function
unicode_literals	2.6.0a2	3.0	PEP 3112: Bytes literals in Python 3000
(Source: https://docs.python.org/2/library/future.html)

from platform import python_version
# function to print the Python version in the following sections
The print function
[back to the section-overview]

Very trivial, and the change in the print-syntax is probably the most widely known change, but still it is worth mentioning: Python 2?s print statement has been replaced by the print() function, meaning that we have to wrap the object that we want to print in parentheses.

Python 2 doesn�t have a problem with additional parentheses, but in contrast, Python 3 would raise a SyntaxError if we called the print function the Python 2-way without the parentheses.

PYTHON 2

print 'Python', python_version()
print 'Hello, World!'
print('Hello, World!')
print "text", ; print 'print more text on the same line'
Python 2.7.6
Hello, World!
Hello, World!
text print more text on the same line
PYTHON 3

print('Python', python_version())
print('Hello, World!')
 
print("some text,", end="")
print(' print more text on the same line')
Python 3.4.1
Hello, World!
some text, print more text on the same line
print 'Hello, World!'
File "", line 1
    print 'Hello, World!'
                            ^
SyntaxError: invalid syntax
Note:

Printing �Hello, World� above via Python 2 looked quite �normal�. However, if we have multiple objects inside the parentheses, we will create a tuple, since print is a �statement� in Python 2, not a function call.

print 'Python', python_version()
print('a', 'b')
print 'a', 'b'
Python 2.7.6
('a', 'b')
a b
Integer division
[back to the section-overview]

This change is particularly dangerous if you are porting code, or if you are executing Python 3 code in Python 2, since the change in integer-division behavior can often go unnoticed (it doesn�t raise a SyntaxError).\ So, I still tend to use a float(3)/2 or 3/2.0 instead of a 3/2 in my Python 3 scripts to save the Python 2 guys some trouble (and vice versa, I recommend a from __future__ import division in your Python 2 scripts).

PYTHON 2

print 'Python', python_version()
print '3 / 2 =', 3 / 2
print '3 // 2 =', 3 // 2
print '3 / 2.0 =', 3 / 2.0
print '3 // 2.0 =', 3 // 2.0
Python 2.7.6
3 / 2 = 1
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
PYTHON 3

print('Python', python_version())
print('3 / 2 =', 3 / 2)
print('3 // 2 =', 3 // 2)
print('3 / 2.0 =', 3 / 2.0)
print('3 // 2.0 =', 3 // 2.0)
Python 3.4.1
3 / 2 = 1.5
3 // 2 = 1
3 / 2.0 = 1.5
3 // 2.0 = 1.0
Unicode
[back to the section-overview]

Python 2 has ASCII str() types, separate unicode(), but no byte type.

Now, in Python 3, we finally have Unicode (utf-8) strings, and 2 byte classes: byte and bytearrays.

PYTHON 2

print 'Python', python_version()
Python 2.7.6
print type(unicode('this is like a python3 str type'))
&lt;type 'unicode'&gt;
print type(b'byte type does not exist')
&lt;type 'str'&gt;
print 'they are really' + b' the same'
they are really the same
print type(bytearray(b'bytearray oddly does exist though'))
&lt;type 'bytearray'&gt;
PYTHON 3

print('Python', python_version())
print('strings are now utf-8 \u03BCnico\u0394�!')
Python 3.4.1
strings are now utf-8 ?nico?�!
print('Python', python_version(), end="")
print(' has', type(b' bytes for storing data'))
Python 3.4.1 has &lt;class 'bytes'&gt;
print('and Python', python_version(), end="")
print(' also has', type(bytearray(b'bytearrays')))
and Python 3.4.1 also has &lt;class 'bytearray'&gt;
'note that we cannot add a string' + b'bytes for data'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
 in ()
----&gt; 1 'note that we cannot add a string' + b'bytes for data'
 
TypeError: Can't convert 'bytes' object to str implicitly
xrange
[back to the section-overview]

The usage of xrange() is very popular in Python 2.x for creating an iterable object, e.g., in a for-loop or list/set-dictionary-comprehension.\ The behavior was quite similar to a generator (i.e., �lazy evaluation�), but here the xrange-iterable is not exhaustible � meaning, you could iterate over it infinitely.

Thanks to its �lazy-evaluation�, the advantage of the regular range() is that xrange() is generally faster if you have to iterate over it only once (e.g., in a for-loop). However, in contrast to 1-time iterations, it is not recommended if you repeat the iteration multiple times, since the generation happens every time from scratch!

In Python 3, the range() was implemented like the xrange() function so that a dedicated xrange() function does not exist anymore (xrange() raises a NameError in Python 3).

import timeit
 
n = 10000
def test_range(n):
    for i in range(n):
        pass
 
def test_xrange(n):
    for i in xrange(n):
        pass
PYTHON 2

print 'Python', python_version()
 
print '\ntiming range()'
%timeit test_range(n)
 
print '\n\ntiming xrange()'
%timeit test_xrange(n)
Python 2.7.6
 
timing range()
1000 loops, best of 3: 433 �s per loop
 
timing xrange()
1000 loops, best of 3: 350 �s per loop
PYTHON 3

print('Python', python_version())
 
print('\ntiming range()')
%timeit test_range(n)
Python 3.4.1
 
timing range()
1000 loops, best of 3: 520 �s per loop
print(xrange(10))
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
 in ()
----&gt; 1 print(xrange(10))
 
NameError: name 'xrange' is not defined
NOTE ABOUT THE SPEED DIFFERENCES IN PYTHON 2 AND 3

Some people pointed out the speed difference between Python 3?s range() and Python2?s xrange(). Since they are implemented the same way one would expect the same speed. However the difference here just comes from the fact that Python 3 generally tends to run slower than Python 2.

def test_while():
    i = 0
    while i &lt; 20000:
        i += 1
    return
 
print('Python', python_version())
%timeit test_while()
Python 3.4.1
100 loops, best of 3: 2.68 ms per loop
print 'Python', python_version()
%timeit test_while()
Python 2.7.6
1000 loops, best of 3: 1.72 ms per loop
 

Raising exceptions
[back to the section-overview]

Where Python 2 accepts both notations, the �old� and the �new� syntax, Python 3 chokes (and raises a SyntaxError in turn) if we don�t enclose the exception argument in parentheses:

PYTHON 2

print 'Python', python_version()
Python 2.7.6
raise IOError, "file error"
---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
 in ()
----&gt; 1 raise IOError, "file error"
 
IOError: file error
raise IOError("file error")
---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
 in ()
----&gt; 1 raise IOError("file error")
 
IOError: file error
PYTHON 3

print('Python', python_version())
Python 3.4.1
raise IOError, "file error"
File "", line 1
raise IOError, "file error"
                     ^
SyntaxError: invalid syntax
The proper way to raise an exception in Python 3:

print('Python', python_version())
raise IOError("file error")
 
Python 3.4.1
---------------------------------------------------------------------------
OSError                                   Traceback (most recent call last)
 in ()
      1 print('Python', python_version())
----&gt; 2 raise IOError("file error")
 
OSError: file error
 

Handling exceptions
[back to the section-overview]

Also the handling of exceptions has slightly changed in Python 3. In Python 3 we have to use the �as� keyword now

PYTHON 2

print 'Python', python_version()
try:
    let_us_cause_a_NameError
except NameError, err:
    print err, '--&gt; our error message'
Python 2.7.6
name 'let_us_cause_a_NameError' is not defined --&gt; our error message
PYTHON 3

print('Python', python_version())
try:
    let_us_cause_a_NameError
except NameError as err:
    print(err, '--&gt; our error message')
Python 3.4.1
name 'let_us_cause_a_NameError' is not defined --&gt; our error message
 

The next() function and .next() method
[back to the section-overview]

Since next() (.next()) is such a commonly used function (method), this is another syntax change (or rather change in implementation) that is worth mentioning: where you can use both the function and method syntax in Python 2.7.5, the next() function is all that remains in Python 3 (calling the .next() method raises an AttributeError).

PYTHON 2

print 'Python', python_version()
 
my_generator = (letter for letter in 'abcdefg')
 
next(my_generator)
my_generator.next()
Python 2.7.6
'b'
PYTHON 3

print('Python', python_version())
 
my_generator = (letter for letter in 'abcdefg')
 
next(my_generator)
Python 3.4.1
'a'
my_generator.next()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
 in ()
----&gt; 1 my_generator.next()
 
AttributeError: 'generator' object has no attribute 'next'
 

For-loop variables and the global namespace leak
[back to the section-overview]

Good news is: In Python 3.x for-loop variables don�t leak into the global namespace anymore!

This goes back to a change that was made in Python 3.x and is described in What�s New In Python 3.0 as follows:

�List comprehensions no longer support the syntactic form [... for var in item1, item2, ...]. Use [... for var in (item1, item2, ...)] instead. Also note that list comprehensions have different semantics: they are closer to syntactic sugar for a generator expression inside a list() constructor, and in particular the loop control variables are no longer leaked into the surrounding scope.�

PYTHON 2

print 'Python', python_version()
 
i = 1
print 'before: i =', i
 
print 'comprehension: ', [i for i in range(5)]
 
print 'after: i =', i
Python 2.7.6
before: i = 1
comprehension:  [0, 1, 2, 3, 4]
after: i = 4
PYTHON 3

print('Python', python_version())
 
i = 1
print('before: i =', i)
 
print('comprehension:', [i for i in range(5)])
 
print('after: i =', i)
Python 3.4.1
before: i = 1
comprehension: [0, 1, 2, 3, 4]
after: i = 1
 

Comparing unorderable types
[back to the section-overview]

Another nice change in Python 3 is that a TypeError is raised as warning if we try to compare unorderable types.

PYTHON 2

print 'Python', python_version()
print "[1, 2] &gt; 'foo' = ", [1, 2] &gt; 'foo'
print "(1, 2) &gt; 'foo' = ", (1, 2) &gt; 'foo'
print "[1, 2] &gt; (1, 2) = ", [1, 2] &gt; (1, 2)
Python 2.7.6
[1, 2] &gt; 'foo' =  False
(1, 2) &gt; 'foo' =  True
[1, 2] &gt; (1, 2) =  False
PYTHON 3

print('Python', python_version())
print("[1, 2] &gt; 'foo' = ", [1, 2] &gt; 'foo')
print("(1, 2) &gt; 'foo' = ", (1, 2) &gt; 'foo')
print("[1, 2] &gt; (1, 2) = ", [1, 2] &gt; (1, 2))
Python 3.4.1
 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
 in ()
      1 print('Python', python_version())
----&gt; 2 print("[1, 2] &gt; 'foo' = ", [1, 2] &gt; 'foo')
      3 print("(1, 2) &gt; 'foo' = ", (1, 2) &gt; 'foo')
      4 print("[1, 2] &gt; (1, 2) = ", [1, 2] &gt; (1, 2))
 
TypeError: unorderable types: list() &gt; str()
 

Parsing user inputs via input()
[back to the section-overview]

Fortunately, the input() function was fixed in Python 3 so that it always stores the user inputs as str objects. In order to avoid the dangerous behavior in Python 2 to read in other types than strings, we have to use raw_input() instead.

PYTHON 2

Python 2.7.6
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
 
&gt;&gt;&gt; my_input = input('enter a number: ')
 
enter a number: 123
 
&gt;&gt;&gt; type(my_input)
&lt;type 'int'&gt;
 
&gt;&gt;&gt; my_input = raw_input('enter a number: ')
 
enter a number: 123
 
type(my_input)
&lt;type 'str'&gt;
PYTHON 3

Python 3.4.1
[GCC 4.2.1 (Apple Inc. build 5577)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
 
&gt;&gt;&gt; my_input = input('enter a number: ')
 
enter a number: 123
 
&gt;&gt;&gt; type(my_input)
&lt;class 'str'&gt;
 

Returning iterable objects instead of lists
[back to the section-overview]

As we have already seen in the xrange section, some functions and methods return iterable objects in Python 3 now � instead of lists in Python 2.

Since we usually iterate over those only once anyway, I think this change makes a lot of sense to save memory. However, it is also possible � in contrast to generators � to iterate over those multiple times if needed, it is aonly not so efficient.

And for those cases where we really need the list-objects, we can simply convert the iterable object into a list via the list() function.

PYTHON 2

print 'Python', python_version()
 
print range(3)
print type(range(3))
Python 2.7.6
[0, 1, 2]
&lt;type 'list'&gt;
PYTHON 3

print('Python', python_version())
 
print(range(3))
print(type(range(3)))
print(list(range(3)))
Python 3.4.1
range(0, 3)
&lt;class 'range'&gt;
[0, 1, 2]
Some more commonly used functions and methods that don�t return lists anymore in Python 3:

zip()
map()
filter()
dictionary�s .keys() method
dictionary�s .values() method
dictionary�s .items() method
 



Python Program to Swap Variables Without Temporary Variable
In python programming, there is a simple construct to swap variables. The following code does the same as above but without the use of any temporary variable.


x,y = y,x
If the variables are both numbers, we can use arithmetic operations to do the same. It might not look intuitive at the first sight. But if you think about it, its pretty easy to figure it out.Here are a few example

Addition and Subtraction


x = x + y
y = x - y
x = x - y
Multiplication and Division


x = x * y
y = x / y
x = x / y


Python Program to Generate a Random Number

import random

print(random.randint(0,9))


# Python program to check if the input number is prime or not


num = int(input("Enter a number: "))

# prime numbers are greater than 1
if num > 1:
   # check for factors
   for i in range(2,num):
       if (num % i) == 0:
           print(num,"is not a prime number")
           print(i,"times",num//i,"is",num)
           break
   else:
       print(num,"is a prime number")



# Python program to find the factorial of a number provided by the user.

# take input from the user
num = int(input("Enter a number: "))
factorial = 1

# check if the number is negative, positive or zero
if num < 0:
   print("Sorry, factorial does not exist for negative numbers")
elif num == 0:
   print("The factorial of 0 is 1")
else:
   for i in range(1,num + 1):
       factorial = factorial*i
   print("The factorial of",num,"is",factorial)




# Program to find the ASCII value of the given character

# Take character from user
c = input("Enter a character: ")

print("The ASCII value of '" + c + "' is",ord(c))
Output 1


Enter a character: p
The ASCII value of 'p' is 112



8.5. User-defined Exceptions
Programs may name their own exceptions by creating a new exception class (see Classes for more about Python classes). Exceptions should typically be derived from the Exception class, either directly or indirectly. For example:

>>>
>>> class MyError(Exception):
...     def __init__(self, value):
...         self.value = value
...     def __str__(self):
...         return repr(self.value)
...
>>> try:
...     raise MyError(2*2)
... except MyError as e:
...     print 'My exception occurred, value:', e.value
...
My exception occurred, value: 4
>>> raise MyError('oops!')
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
__main__.MyError: 'oops!'
In this example, the default __init__() of Exception has been overridden. The new behavior simply creates the value attribute. This replaces the default behavior of creating the args attribute.

Exception classes can be defined which do anything any other class can do, but are usually kept simple, often only offering a number of attributes that allow information about the error to be extracted by handlers for the exception. When creating a module that can raise several distinct errors, a common practice is to create a base class for exceptions defined by that module, and subclass that to create specific exception classes for different error conditions:

class Error(Exception):
    """Base class for exceptions in this module."""
    pass

class InputError(Error):
    """Exception raised for errors in the input.

    Attributes:
        expr -- input expression in which the error occurred
        msg  -- explanation of the error
    """

    def __init__(self, expr, msg):
        self.expr = expr
        self.msg = msg

class TransitionError(Error):
    """Raised when an operation attempts a state transition that's not
    allowed.

    Attributes:
        prev -- state at beginning of transition
        next -- attempted new state
        msg  -- explanation of why the specific transition is not allowed
    """

    def __init__(self, prev, next, msg):
        self.prev = prev
        self.next = next
        self.msg = msg
Most exceptions are defined with names that end in �Error,� similar to the naming of the standard exceptions.

Many standard modules define their own exceptions to report errors that may occur in functions they define. More information on classes is presented in chapter Classes.





Q.
Why you specify type and name of the exception in your custom
exceptions,
but not in built in exceptions
except IOError:
print "no file by the name ccy_rates*.txt"

except MyError, e:
print e.msg

ANS: 

You can say:

except IOError, e:
print e.msg
And you can say:

except MyError:
print "whatever I want"
It all depends on what you want to do.

Q.Also, when you do:

try: raise MyError(23)

In "try: MyError(23) ", you are calling MyError class, but actually get
instantiated in except MyError, e: ?

Ans :

I don't understand what you are actually asking, but I will try my best.
raise MyError(23)

calls the class MyError and creates and instance, and that instance is
then used as an argument to the raise statement. You can also do this:

instance = MyError(23)
raise instance

You don't need the try block unless you want to catch the exception. The
exception itself it actually raised by the "raise" statement, not the
"except" statement. The "except" statement _catches_ the exception.

Try typing these lines in the interactive interpreter:

try:
print "before the exception"
raise Exception("an error occurred")
print "this line is never executed"
print "neither is this"
except Exception, e:
print "the exception is:"
print e
print e.message




Question asked in Persistant:

>>> a=['a','b','c']
>>> a[10:]
[]
>>>

for loop:


>>>
>>> words=["kaila", "ghgd", "wersfd"]
>>> for word in words:
...     print word
...
kaila
ghgd
wersfd
>>> for word in words:
...     print words
...
['kaila', 'ghgd', 'wersfd']
['kaila', 'ghgd', 'wersfd']
['kaila', 'ghgd', 'wersfd']




4.2. for Statements
The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Python�s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):

>>>
>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
...     print w, len(w)
...
cat 3
window 6
defenestrate 12
If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:

>>>
>>> for w in words[:]:  # Loop over a slice copy of the entire list.
...     if len(w) > 6:
...         words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']




Important warning: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. For example, the following function accumulates the arguments passed to it on subsequent calls:

def f(a, L=[]):
    L.append(a)
    return L

print f(1)
print f(2)
print f(3)
This will print

[1]
[1, 2]
[1, 2, 3]

Here we r not getting output like : 
[1] 
[2] 
[3]

bcos default parameter evalutes only once , means only once object is created and items gets added in it 

If you don�t want the default to be shared between subsequent calls, you can write the function like this instead:

def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L



5.1.3. Functional Programming Tools

There are three built-in functions that are very useful when used with lists: filter(), map(), and reduce().

filter(function, sequence) returns a sequence consisting of those items from the sequence for which function(item) is true. If sequence is a str, unicode or tuple, the result will be of the same type; otherwise, it is always a list. For example, to compute a sequence of numbers divisible by 3 or 5:

>>>
>>> def f(x): return x % 3 == 0 or x % 5 == 0
...
>>> filter(f, range(2, 25))
[3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24]
map(function, sequence) calls function(item) for each of the sequence�s items and returns a list of the return values. For example, to compute some cubes:

>>>
>>> def cube(x): return x*x*x
...
>>> map(cube, range(1, 11))
[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]
More than one sequence may be passed; the function must then have as many arguments as there are sequences and is called with the corresponding item from each sequence (or None if some sequence is shorter than another). For example:

>>>
>>> seq = range(8)
>>> def add(x, y): return x+y
...
>>> map(add, seq, seq)
[0, 2, 4, 6, 8, 10, 12, 14]
reduce(function, sequence) returns a single value constructed by calling the binary function function on the first two items of the sequence, then on the result and the next item, and so on. For example, to compute the sum of the numbers 1 through 10:

>>>
>>> def add(x,y): return x+y
...
>>> reduce(add, range(1, 11))
55
If there�s only one item in the sequence, its value is returned; if the sequence is empty, an exception is raised.

A third argument can be passed to indicate the starting value. In this case the starting value is returned for an empty sequence, and the function is first applied to the starting value and the first sequence item, then to the result and the next item, and so on. For example,

>>>
>>> def sum(seq):
...     def add(x,y): return x+y
...     return reduce(add, seq, 0)
...
>>> sum(range(1, 11))
55
>>> sum([])
0
Don�t use this example�s definition of sum(): since summing numbers is such a common need, a built-in function sum(sequence) is already provided, and works exactly like this.






Another useful data type built into Python is the dictionary (see Mapping Types � dict). Dictionaries are sometimes found in other languages as �associative memories� or �associative arrays�. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can�t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like append() and extend().





When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the enumerate() function.

>>>
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...     print i, v
...
0 tic
1 tac
2 toe
To loop over two or more sequences at the same time, the entries can be paired with the zip() function.

>>>
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...     print 'What is your {0}?  It is {1}.'.format(q, a)
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.





To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the reversed() function.

>>>
>>> for i in reversed(xrange(1,10,2)):
...     print i
...
9
7
5
3
1
To loop over a sequence in sorted order, use the sorted() function which returns a new sorted list while leaving the source unaltered.

>>>
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
...     print f
...
apple
banana
orange
pear






5.7. More on Conditions
The conditions used in while and if statements can contain any operators, not just comparisons.

The comparison operators in and not in check whether a value occurs (does not occur) in a sequence. The operators is and is not compare whether two objects are really the same object; this only matters for mutable objects like lists. All comparison operators have the same priority, which is lower than that of all numerical operators.

Comparisons can be chained. For example, a < b == c tests whether a is less than b and moreover b equals c.

Comparisons may be combined using the Boolean operators and and or, and the outcome of a comparison (or of any other Boolean expression) may be negated with not. These have lower priorities than comparison operators; between them, not has the highest priority and or the lowest, so that A and not B or C is equivalent to (A and (not B)) or C. As always, parentheses can be used to express the desired composition.

The Boolean operators and and or are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if A and C are true but B is false, A and B and C does not evaluate the expression C. When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument.

It is possible to assign the result of a comparison or other Boolean expression to a variable. For example,

>>>
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
Note that in Python, unlike C, assignment cannot occur inside expressions. C programmers may grumble about this, but it avoids a common class of problems encountered in C programs: typing = in an expression when == was intended.



A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py appended. Within a module, the module�s name (as a string) is available as the value of the global variable __name__. For instance, use your favorite text editor to create a file called fibo.py in the current directory with the following contents:




6.4. Packages
Packages are a way of structuring Python�s module namespace by using �dotted module names�. For example, the module name A.B designates a submodule named B in a package named A. Just like the use of modules saves the authors of different modules from having to worry about each other�s global variable names, the use of dotted module names saves the authors of multi-module packages like NumPy or the Python Imaging Library from having to worry about each other�s module names.

Suppose you want to design a collection of modules (a �package�) for the uniform handling of sound files and sound data. There are many different sound file formats (usually recognized by their extension, for example: .wav, .aiff, .au), so you may need to create and maintain a growing collection of modules for the conversion between the various file formats. There are also many different operations you might want to perform on sound data (such as mixing, adding echo, applying an equalizer function, creating an artificial stereo effect), so in addition you will be writing a never-ending stream of modules to perform these operations. Here�s a possible structure for your package (expressed in terms of a hierarchical filesystem):

sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
When importing the package, Python searches through the directories on sys.path looking for the package subdirectory.

The __init__.py files are required to make Python treat the directories as containing packages; this is done to prevent directories with a common name, such as string, from unintentionally hiding valid modules that occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it can also execute initialization code for the package or set the __all__ variable, described later.

Users of the package can import individual modules from the package, for example:

import sound.effects.echo
This loads the submodule sound.effects.echo. It must be referenced with its full name.

sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
An alternative way of importing the submodule is:

from sound.effects import echo
This also loads the submodule echo, and makes it available without its package prefix, so it can be used as follows:

echo.echofilter(input, output, delay=0.7, atten=4)
Yet another variation is to import the desired function or variable directly:

from sound.effects.echo import echofilter
Again, this loads the submodule echo, but this makes its function echofilter() directly available:

echofilter(input, output, delay=0.7, atten=4)
Note that when using from package import item, the item can be either a submodule (or subpackage) of the package, or some other name defined in the package, like a function, class or variable. The import statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts to load it. If it fails to find it, an ImportError exception is raised.

Contrarily, when using syntax like import item.subitem.subsubitem, each item except for the last must be a package; the last item can be a module or a package but can�t be a class or function or variable defined in the previous item.



Note : whwnever we run python file one complied file with .pyc extention gets created in same folder




Counter



A Counter is a container that keeps track of how many times equivalent values are added. It can be used to implement the same algorithms for which bag or multiset data structures are commonly used in other languages.

Initializing

Counter supports three forms of initialization. Its constructor can be called with a sequence of items, a dictionary containing keys and counts, or using keyword arguments mapping string names to counts.

import collections

print collections.Counter(['a', 'b', 'c', 'a', 'b', 'b'])
print collections.Counter({'a':2, 'b':3, 'c':1})
print collections.Counter(a=2, b=3, c=1)
The results of all three forms of initialization are the same.

$ python collections_counter_init.py

Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'b': 3, 'a': 2, 'c': 1})



Identify duplicate values in a list in Python


These answers are O(n), so a little more code than using mylist.count() but much more efficient as mylist gets longer

If you just want to know the duplicates, use collections.Counter

from collections import Counter
mylist = [20, 30, 25, 20]
[k for k,v in Counter(mylist).items() if v>1]



File Operations:


To write something other than a string, it needs to be converted to a string first:

>>>
>>> value = ('the answer', 42)
>>> s = str(value)
>>> f.write(s)
f.tell() returns an integer giving the file object�s current position in the file, measured in bytes from the beginning of the file. To change the file object�s position, use f.seek(offset, from_what). The position is computed from adding offset to a reference point; the reference point is selected by the from_what argument. A from_what value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. from_what can be omitted and defaults to 0, using the beginning of the file as the reference point.

>>>
>>> f = open('workfile', 'r+')
>>> f.write('0123456789abcdef')
>>> f.seek(5)     # Go to the 6th byte in the file
>>> f.read(1)
'5'
>>> f.seek(-3, 2) # Go to the 3rd byte before the end
>>> f.read(1)
'd'






7.2.2. Saving structured data with json
Strings can easily be written to and read from a file. Numbers take a bit more effort, since the read() method only returns strings, which will have to be passed to a function like int(), which takes a string like '123' and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated.

Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called json can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine.

Note The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability.
If you have an object x, you can view its JSON string representation with a simple line of code:

>>>
>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
Another variant of the dumps() function, called dump(), simply serializes the object to a file. So if f is a file object opened for writing, we can do this:

json.dump(x, f)
To decode the object again, if f is a file object which has been opened for reading:

x = json.load(f)
This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the json module contains an explanation of this.

See also pickle - the pickle module
Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker.


Q.

Both the following snippets of code do the same thing. They catch every exception and execute the code in the except: block

Snippet 1 -

try:
    #some code that may throw an exception
except:
    #exception handling code
Snippet 2 -

try:
    #some code that may throw an exception
except Exception as e:
    #exception handling code
What is exactly the difference in both the constructs?


Ans:

In the second you can access the attributes of the exception object:

>>> def catch():
...     try:
...         asd()
...     except Exception as e:
...         print e.message, e.args
... 
>>> catch()
global name 'asd' is not defined ("global name 'asd' is not defined",)
But it doesn't catch BaseException or the system-exiting exceptions SystemExit, KeyboardInterrupt and GeneratorExit:

>>> def catch():
...     try:
...         raise BaseException()
...     except Exception as e:
...         print e.message, e.args
... 
>>> catch()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in catch
BaseException
Which a bare except does:

>>> def catch():
...     try:
...         raise BaseException()
...     except:
...         pass
... 
>>> catch()
>>> 
See the Built-in Exceptions section of the docs and the Errors and Exceptions section of the tutorial for more info.


Types of exceptions:

except (RuntimeError, TypeError, NameError):
...     pass





8.7. Predefined Clean-up Actions
Some objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen.

for line in open("myfile.txt"):
    print line,
The problem with this code is that it leaves the file open for an indeterminate amount of time after the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The with statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly.

with open("myfile.txt") as f:
    for line in f:
        print line,
After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Other objects which provide predefined clean-up actions will indicate this in their documentation.


As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances:

class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']

Correct design of the class should use an instance variable instead:

class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']



More on classes:


Often, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention.

Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example:

# Function defined outside the class
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'hello world'
    h = g
Now f, g and h are all attributes of class C that refer to function objects, and consequently they are all methods of instances of C � h being exactly equivalent to g. Note that this practice usually only serves to confuse the reader of a program.

Methods may call other methods by using method attributes of the self argument:

class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)
Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we�ll find some good reasons why a method would want to reference its own class.

Each value is an object, and therefore has a class (also called its type). It is stored as object.__class__.

9.5. Inheritance



Of course, a language feature would not be worthy of the name �class� without supporting inheritance. The syntax for a derived class definition looks like this:

class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
The name BaseClassName must be defined in a scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module:

class DerivedClassName(modname.BaseClassName):
Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class.

There�s nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object.

Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively virtual.)

An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call BaseClassName.methodname(self, arguments). This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as BaseClassName in the global scope.)

Python has two built-in functions that work with inheritance:

Use isinstance() to check an instance�s type: isinstance(obj, int) will be True only if obj.__class__ is int or some class derived from int.
Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass of int. However, issubclass(unicode, str) is False since unicode is not a subclass of str (they only share a common ancestor, basestring).


9.5.1. Multiple Inheritance
Python supports a limited form of multiple inheritance as well. A class definition with multiple base classes looks like this:

class DerivedClassName(Base1, Base2, Base3):
    <statement-1>
    .
    .
    .
    <statement-N>
For old-style classes, the only rule is depth-first, left-to-right. Thus, if an attribute is not found in DerivedClassName, it is searched in Base1, then (recursively) in the base classes of Base1, and only if it is not found there, it is searched in Base2, and so on.

(To some people breadth first � searching Base2 and Base3 before the base classes of Base1 � looks more natural. However, this would require you to know whether a particular attribute of Base1 is actually defined in Base1 or in one of its base classes before you can figure out the consequences of a name conflict with an attribute of Base2. The depth-first rule makes no differences between direct and inherited attributes of Base1.)

For new-style classes, the method resolution order changes dynamically to support cooperative calls to super(). This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages.

With new-style classes, dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all new-style classes inherit from object, so any case of multiple inheritance provides more than one path to reach object. To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see https://www.python.org/download/releases/2.3/mro/.




indexmodules |next |previous | Python �   Documentation � The Python Tutorial �
10. Brief Tour of the Standard Library
10.1. Operating System Interface
The os module provides dozens of functions for interacting with the operating system:

>>>
>>> import os
>>> os.getcwd()      # Return the current working directory
'C:\\Python26'
>>> os.chdir('/server/accesslogs')   # Change current working directory
>>> os.system('mkdir today')   # Run the command mkdir in the system shell
0
Be sure to use the import os style instead of from os import *. This will keep os.open() from shadowing the built-in open() function which operates much differently.

The built-in dir() and help() functions are useful as interactive aids for working with large modules like os:

>>>
>>> import os
>>> dir(os)
<returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>
For daily file and directory management tasks, the shutil module provides a higher level interface that is easier to use:

>>>
>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
>>> shutil.move('/build/executables', 'installdir')



10.2. File Wildcards
The glob module provides a function for making file lists from directory wildcard searches:

>>>
>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']

10.3. Command Line Arguments



Common utility scripts often need to process command line arguments. These arguments are stored in the sys module�s argv attribute as a list. For instance the following output results from running python demo.py one two three at the command line:

>>>
>>> import sys
>>> print sys.argv
['demo.py', 'one', 'two', 'three']
The getopt module processes sys.argv using the conventions of the Unix getopt() function. More powerful and flexible command line processing is provided by the argparse module.

10.4. Error Output Redirection and Program Termination
The sys module also has attributes for stdin, stdout, and stderr. The latter is useful for emitting warnings and error messages to make them visible even when stdout has been redirected:

>>>
>>> sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one
The most direct way to terminate a script is to use sys.exit().

10.5. String Pattern Matching
The re module provides regular expression tools for advanced string processing. For complex matching and manipulation, regular expressions offer succinct, optimized solutions:

>>>
>>> import re
>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
['foot', 'fell', 'fastest']
>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
'cat in the hat'
When only simple capabilities are needed, string methods are preferred because they are easier to read and debug:

>>>
>>> 'tea for too'.replace('too', 'two')
'tea for two'
10.6. Mathematics
The math module gives access to the underlying C library functions for floating point math:

>>>
>>> import math
>>> math.cos(math.pi / 4.0)
0.70710678118654757
>>> math.log(1024, 2)
10.0
The random module provides tools for making random selections:

>>>
>>> import random
>>> random.choice(['apple', 'pear', 'banana'])
'apple'
>>> random.sample(xrange(100), 10)   # sampling without replacement
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
>>> random.random()    # random float
0.17970987693706186
>>> random.randrange(6)    # random integer chosen from range(6)
4
10.7. Internet Access
There are a number of modules for accessing the internet and processing internet protocols. Two of the simplest are urllib2 for retrieving data from URLs and smtplib for sending mail:

>>>
>>> import urllib2
>>> for line in urllib2.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time
...         print line

<BR>Nov. 25, 09:43:32 PM EST

>>> import smtplib
>>> server = smtplib.SMTP('localhost')
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
... """To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... """)
>>> server.quit()
(Note that the second example needs a mailserver running on localhost.)

10.8. Dates and Times
The datetime module supplies classes for manipulating dates and times in both simple and complex ways. While date and time arithmetic is supported, the focus of the implementation is on efficient member extraction for output formatting and manipulation. The module also supports objects that are timezone aware.

>>>
>>> # dates are easily constructed and formatted
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

>>> # dates support calendar arithmetic
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
10.9. Data Compression
Common data archiving and compression formats are directly supported by modules including: zlib, gzip, bz2, zipfile and tarfile.

>>>
>>> import zlib
>>> s = 'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
10.10. Performance Measurement
Some Python users develop a deep interest in knowing the relative performance of different approaches to the same problem. Python provides a measurement tool that answers those questions immediately.

For example, it may be tempting to use the tuple packing and unpacking feature instead of the traditional approach to swapping arguments. The timeit module quickly demonstrates a modest performance advantage:

>>>
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
In contrast to timeit�s fine level of granularity, the profile and pstats modules provide tools for identifying time critical sections in larger blocks of code.

10.11. Quality Control
One approach for developing high quality software is to write tests for each function as it is developed and to run those tests frequently during the development process.

The doctest module provides a tool for scanning a module and validating tests embedded in a program�s docstrings. Test construction is as simple as cutting-and-pasting a typical call along with its results into the docstring. This improves the documentation by providing the user with an example and it allows the doctest module to make sure the code remains true to the documentation:

def average(values):
    """Computes the arithmetic mean of a list of numbers.

    >>> print average([20, 30, 70])
    40.0
    """
    return sum(values, 0.0) / len(values)

import doctest
doctest.testmod()   # automatically validate the embedded tests
The unittest module is not as effortless as the doctest module, but it allows a more comprehensive set of tests to be maintained in a separate file:

import unittest

class TestStatisticalFunctions(unittest.TestCase):

    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        with self.assertRaises(ZeroDivisionError):
            average([])
        with self.assertRaises(TypeError):
            average(20, 30, 70)

unittest.main() # Calling from the command line invokes all tests
10.12. Batteries Included
Python has a �batteries included� philosophy. This is best seen through the sophisticated and robust capabilities of its larger packages. For example:

The xmlrpclib and SimpleXMLRPCServer modules make implementing remote procedure calls into an almost trivial task. Despite the modules names, no direct knowledge or handling of XML is needed.
The email package is a library for managing email messages, including MIME and other RFC 2822-based message documents. Unlike smtplib and poplib which actually send and receive messages, the email package has a complete toolset for building or decoding complex message structures (including attachments) and for implementing internet encoding and header protocols.
The xml.dom and xml.sax packages provide robust support for parsing this popular data interchange format. Likewise, the csv module supports direct reads and writes in a common database format. Together, these modules and packages greatly simplify data interchange between Python applications and other tools.
Internationalization is supported by a number of modules including gettext, locale, and the codecs package.
Table Of Contents
10. Brief Tour of the Standard Library
10.1. Operating System Interface
10.2. File Wildcards
10.3. Command Line Arguments
10.4. Error Output Redirection and Program Termination
10.5. String Pattern Matching
10.6. Mathematics
10.7. Internet Access
10.8. Dates and Times
10.9. Data Compression
10.10. Performance Measurement
10.11. Quality Control
10.12. Batteries Included
Previous topic
9. Classes

Next topic
11. Brief Tour of the Standard Library � Part II

This Page
Report a Bug
Show Source
Quick search

 Go
Enter search terms or a module, class or function name.

�
indexmodules |next |previous | Python �   Documentation � The Python Tutorial �
� Copyright 1990-2015, Python Software Foundation. 
The Python Software Foundation is a non-profit corporation. Please donate. 
Last updated on May 23, 2015. Found a bug? 
Created using Sphinx 1.2.3.




Get files from Directory Argument, Sorting by Size

import os

# The folder containing files.
directory = "C:\\programs\\"

# Get all files.
list = os.listdir(directory)

# Loop and add files to list.
pairs = []
for file in list:

    # Use join to get full file path.
    location = os.path.join(directory, file)

    # Get size and add to list of tuples.
    size = os.path.getsize(location)
    pairs.append((size, file))

# Sort list of tuples by the first element, size.
pairs.sort(key=lambda s: s[0])

# Display pairs.
for pair in pairs:
    print(pair)

Output

(184, 'file.pl')
(235, 'file.php')
(369, 'file.rb')
(611, 'file.py')



Python has two handy functions for creating lists, or a range of integers that assist in making for loops.

These functions are xrange and range. But you probably already guessed that! :)

The Difference Between xrange and range in Python
Before we get started, let's talk about what makes xrange and range different.

For the most part, xrange and range are the exact same in terms of functionality. They both provide a way to generate a list of integers for you to use, however you please. The only difference is that range returns a Python list object and xrange returns an xrange object.

What does that mean? Good question! It means that xrange doesn't actually generate a static list at run-time like range does. It creates the values as you need them with a special technique called yielding. This technique is used with a type of object known as generators. If you want to read more in depth about generators and the yield keyword, be sure to checkout the article Python generators and the yield keyword.

Okay, now what does that mean? Another good question. That means that if you have a really gigantic range you'd like to generate a list for, say one billion, xrange is the function to use. This is especially true if you have a really memory sensitive system such as a cell phone that you are working with, as range will use as much memory as it can to create your array of integers, which can result in a MemoryError and crash your program. It's a memory hungry beast.

That being said, if you'd like to iterate over the list multiple times, it's probably better to use range. This is because xrange has to generate an integer object every time you access an index, whereas range is a static list and the integers are already "there" to use.

Alright, now on to the good stuff.

How to Use Python's range and xrange
So how do we use range and xrange? Here is the simplest example:

1
2
3
4
5
6
7
8
9
10
11
12
13
>>> for i in xrange(10):
...     print(i)
...
0
1
2
3
4
5
6
7
8
9
Great! Simple enough. Note that you could also use range in place of xrange here, but I personally like xrange better. Maybe it's that sexy "x" in the front. :)

Alright, explanation time. The functions xrange and range take in three arguments in total, however two of them are optional. The arguments are "start", "stop" and "step". "start" is what integer you'd like to start your list with, "stop" is what integer you'd like your list to stop at, and "step" is what your list elements will increment by.

Python's xrange and range with Odd Numbers

Say we wanted only odd numbers. Here's what we could do:

1
2
3
4
5
6
7
8
>>> for i in xrange(1, 10, 2):
...     print(i)
...
1
3
5
7
9
We told Python that we would like the first element to be one, the last element to be one less than ten, and that we'd like each element to go up by two. Really simple stuff.

Python's xrange and range with Negative Numbers

Alright, so what about if we want a negative list?

Simple. Here's an example:

1
2
3
4
5
6
7
8
9
10
11
12
>>> for i in xrange(-1, -10, -1):
...     print(i)
...
-1
-2
-3
-4
-5
-6
-7
-8
-9
That's it! All we have to do is change the "start", "stop" and "step" to negative numbers. Awesome. Please note that you must do it this way for negative lists. Trying to use xrange(-10) will not work because xrange and range use a default "step" of one.

Another Python xrange and range Example

Here's one more example of even numbers between 100 and 120:

1
2
3
4
5
6
7
8
9
10
11
12
13
>>> for i in xrange(100, 120, 2):
...     print(i)
...
100
102
104
106
108
110
112
114
116
118
And that's pretty much it for xrange and range. If you would like a more technical explanation of what these two functions do, please consult the Python docs for xrange and range.

Note that if  "start" is larger than "stop", the list returned will be empty. Also, if "step" is larger that "stop" minus "start", then "stop" will be raised to the value of  "step" and the list will contain "start" as its only element.

Here's a clearer picture:

1
2
3
4
5
6
7
8
>>> for i in xrange(70, 60):
...     print(i)
...
# Nothing is printed
>>> for i in xrange(10, 60, 70):
...     print(i)
...
10



Deprecation of Python's xrange
One more thing to add. In Python 3.x, the xrange function does not exist anymore. The range function now does what xrange does in Python 2.x, so to keep your code portable, you might want to stick to using range instead. Of course, you could always use the 2to3 tool that Python provides in order to convert your code, but that introduces more complexity.

The reason why xrange was removed was because it is basically always better to use it, and the performance effects are negligible. So Python 3.x's range function is xrange from Python 2.x.




EMC interview question:

1. how to save student name roll no marks using dictionary

-->>

1. Using List :

>>> d={'s':[12,23],'w':[34,45]}
>>> d[s]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 's' is not defined
>>> d['s']
[12, 23]
>>> d['s'][0]
12
>>> d['s'][1]
23
>>> d['w']
[34, 45]
>>> d['w'][0]
34
>>> d['w'][1]
45
>>>


Using Tuple:

>>> dl={'p':(11,22),'w':(33,44)}
>>> dl[p]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'p' is not defined
>>> dl['p']
(11, 22)
>>> dl['p'][0]
11
>>> dl['p'][1]
22
>>>


Using Dictionary:

Like List/Tuple you cant write like:

>>> ss={'ww':{55,66}}
  File "<stdin>", line 1
    ss={'ww':{55,66}}
                ^
SyntaxError: invalid syntax
>>>


You can use like:


>>> dd={'q':{'marks':23,'roll':44}}
>>> dd['q']
{'roll': 44, 'marks': 23}
>>> dd['q']['roll']
44
>>> dd['q']['marks']
23










Automation Framework:




Test Automation Frameworks - Stuff you must Know!

 
What is a Framework ?

Instead of providing a bookish definition of a framework, lets consider an example.

I am sure you have attended a seminar / lecture / conference where the participants was asked to observe the following guidelines -

Participants should occupy their seat 5 minutes before start of lecture
Bring along a notebook and pen for note taking.
Read the abstract so you have an idea of what the presentation will be about.
Mobile Phones should be set on silent
Use the exit gates at opposite end to the speaker should you require to leave in middle of the lecture.
Questions will be taken at the end of the session
Do you think you can conduct a seminar WITHOUT observing these guidelines????

The answer is a big YES! Certainly you can conduct a seminar / lecture / conference / demonstration without above guidelines (in fact some of us will not follow them even though there are laid ... :-)

But if the guidelines are followed it will result in beneficial outcome like reduced audience distraction during lecture and increased participant retention and understanding of the subject matter.

Based on above, a Framework can be defined as a set of guidelines which when followed produce beneficial results.

Now what is a TEST Automation Framework ?

A set of guidelines like coding standards , test-data handling , object repository treatment etc... which when followed during automation scripting produce beneficial outcomes like increase code re-usage , higher portability , reduced script maintenance cost etc. Mind you these are just guidelines and not rules; they are not mandatory and you can still script without following the guidelines. But you will miss out on the advantages of having a Framework.

What are the various Automation Frameworks available?

1) Linear Scripting
2)The Test Library Architecture Framework.
3)The Data-Driven Testing Framework.
4)The Keyword-Driven or Table-Driven Testing Framework.
5)The Hybrid Test Automation Framework.

Lets look at them in detail -

1) Linear Scripting - Record & Playback
It is the simplest of all Frameworks and also know as "Record & Playback".In this Framework , Tester manually records each step ( Navigation and User Inputs), Inserts Checkpoints ( Validation Steps) in the first round . He then , Plays back the recorded script in the subsequent rounds.

Ex : Consider logging into Flight Reservation Application and checking whether the application has loaded on successful log-on. Here , the tester will simply record the steps and add validation steps.

?
1
2
3
4
5
6
7
8
9
10
11
SystemUtil.Run "flight4a.exe","","","open"
 
    Dialog("Login").WinEdit("Agent Name:").Set "Guru99"
 
    Dialog("Login").WinEdit("Password:").Set "Mercury"
 
    Dialog("Login").WinButton("OK").Click
 
    'Check Flight Reservation Window has loaded after successful log-on
 
    Window("Flight Reservation").Check CheckPoint("Flight Reservation")
Advantages

Fastest way to generate script
Automation expertise not required
Easiest way to learn the features of the Testing Tool
Disadvantages

Little reuse of scripts
Test data is hard coded into the script
Maintenance Nightmare



2)The Test Library Architecture Framework.
It is also know as "Structured Scripting" or "Functional Decomposition".

In this Framework , test scripts are initially recorded by "Record & Playback" method. Later, common tasks inside the scripts are identified and grouped into Functions. These Functions are called by main test script called Driver in different ways to create test cases.

Ex:Using the same example as above, the function for logging in to Flight Reservation will look like .

?
1
2
3
4
5
6
7
8
9
10
Function Login()
SystemUtil.Run "flight4a.exe","","","open"
 
  Dialog("Login").WinEdit("Agent Name:").Set "Guru99"
 
  Dialog("Login").WinEdit("Password:").Set "Mercury"
 
  Dialog("Login").WinButton("OK").Click
 
  End Function
Now, you will call this function in the main script as follows

	    Call Login()

      ---------------------------

      Other Function calls / Test Steps.

      ---------------------------
Advantages

Higher level of code reuse is achieved in Structured Scripting as compared to "Record & Playback"
The automation scripts are less costly to develop due to higher code re-use
Easier Script Maintenance
Disadvantages

Technical expertise is necessary to write Scripts using Test Library Framework.
More time is needed to plan and prepare test scripts.
Test Data is hard coded within the scripts


3)The Data-Driven Testing Framework.


In this Framework , while Test case logic resides in Test Scripts, the Test Data is separated and kept outside the Test Scripts.Test Data is read from the external files (Excel Files, Text Files, CSV Files, ODBC Sources, DAO Objects, ADO Objects) and are loaded into the variables inside the Test Script. Variables are used both for Input values and for Verification values. Test Scripts themselves are prepared either using Linear Scripting or Test Library Framework.

Ex: Developing the Flight Reservation Login script using this method will involve two steps.

Step 1) Create a Test - Data file which could be Excel , CSV , or any other database source.

AgentName

Password

Jimmy

Mercury

Tina

MERCURY

Bill

MerCURY

Step 2) Develop Test Script and make references to your Test- Data source.

?
1
2
3
4
5
6
7
8
9
10
11
12
SystemUtil.Run "flight4a.exe","","","open"
Dialog("Login").WinEdit("Agent Name:").Set DataTable("AgentName", dtGlobalSheet)
 
     Dialog("Login").WinEdit("Password:").Set DataTable("Password", dtGlobalSheet)
 
     Dialog("Login").WinButton("OK").Click
 
     'Check Flight Reservation Window has loaded
 
     Window("Flight Reservation").Check CheckPoint("Flight Reservation")
 
     **Note "dtGlobalSheet" is the default excel sheet provided by QTP.
Advantages

Changes to the Test Scripts do not affect the Test Data
Test Cases can be executed with multiple Sets of Data
A Variety of Test Scenarios can be executed by just varying the Test Data in the External Data File
DisAdvantages

More time is needed to plan and prepare both Test Scripts and Test Data


4)The Keyword-Driven or Table-Driven Testing Framework.


The Keyword-Driven or Table-Driven framework requires the development of data tables and keywords, independent of the test automation tool used to execute them . Tests can be designed with or without the Application. In a keyword-driven test, the functionality of the application-under-test is documented in a table as well as in step-by-step instructions for each test.

There are 3 basis components of a Keyword Driven Framework viz. Keyword , Application Map , Component Function.

What is a Keyword ?

Keyword is an Action that can be performed on a GUI Component. Ex . For GUI Component Textbox some Keywords ( Action) would be InputText, VerifyValue, VerifyProperty and so on.

What is Application Map?

An Application Map Provides Named References for GUI Components. Application Maps are nothing but "Object Repositry"

What is Component Function?

Component Functions are those functions that actively manipulate or interrogate GUI component. An example of a function would be click on web button with all error handling , enter data in a Web Edit with all error handling. Component functions could be application dependent or independent.

Ex: To understand Keyword View lets take the same example. It invovles 2 steps

Step 1: Creating Data Table (Different from Test-Data Table created in Data Driven Framework). This Data Table contains Action to be performed on GUI Objects and correspoding arguments if any. Each row respresents one Test Step.


 
Object

(Application MAP)

Action

(KEYWORDS)

Argument

WinEdit(Agent Name)

Set

Guru99

WinEdit(Password)

Set

Mercury

WinButton(OK)

Click

Window(Flight Reservation)

Verify

Exists

Step 2: Writing Code in the form of Component Functions.

Once you've created your data table(s), you simply write a program or a set of scripts that reads in each step, executes the step based on the keyword contained the Action field, performs error checking, and logs any relevant information. This program or set of scripts would look similar to the pseudo code below:

?
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
Function main()
 
{
 
           Call ConnectTable(Name of the Table) {   //Calling Function for connecting to the table.
 
                   while (Call TableParser() != -1)  //Calling function for Parsing and extracting values from the table.
 
                  {
 
                      Pass values to appropriate  COMPONENT functions. Like Set(Object Name , Argument) ex. Set( Agent Name , Guru99).
 
                  }
 
           }   
 
                 Call CloseConnection()   //Function for Closing connection after all the operation has been performed.
 
 }   //End of main
Thats all to Keyword Driven Framework.

The advantage of Keyword Driven Framework is that the Keywords are re-usable. To understand this consider you want to verify login operation for a Website say YAHOO MAIL. The table will look like this -

Object

(APPLICATION MAP)

Action

(KEYWORD)

Argument

WebEdit(UserName)

Set

abc@yahoo.com

WebEdit(Password)

Set

xxxxx

WebButton(OK)

Click

Window(Yahoo Mail)

Verify

Loads

If you observe in this case the Keywords Set , Click , Verify remain the same for which corresponding component functions are already developed. All you need to do is change the Application Mapping (Object Repository) from earlier Flight Reservation to Yahoo Mail , with change in argument values and the same script will work!

Advantages

Provides high code re-usability
Test Tool Independent
Independent of Application Under Test, same script works for AUT (with some limitations)
Tests can be designed with or without AUT
Disadvantages

Initial investment being pretty high, the benefits of this can only be realized if the application is considerably big and the test scripts are to be maintained for quite a few years.
High Automation expertise is required to create the Keyword Driven Framework.
NOTE : Even though QTP advertises itself as KeyWord Driven Framework, you can not achieve complete test tool and application idependence using QTP.

5)The Hybrid Test Automation Framework.
As the name suggests this framework is the combination of one or more frameworks discussed above pulling from their strengths and trying to mitigate their weaknesses. This hybrid test automation framework is what most frameworks evolve into over time and multiple projects. Maximum industry uses Keyword Framework in combination of Function decomposition method.

PS: Other Frameworks worth a mention are

Test Modularity Framework
In this framework common task in test script are grouped together as Modules.

Ex:Using Actions in QTP use can create a Modualr Scripts

Sample Script for Login

?
1
2
3
4
5
6
7
8
9
SystemUtil.Run "flight4a.exe","","","open"
 
Dialog("Login").WinEdit("Agent Name:").Set "Guru99"
 
Dialog("Login").WinEdit("Password:").Set "Mercury"
 
Dialog("Login").WinButton("OK").Click
 
'End of Script
Now you can call this Action in the main script as follows -

	RunAction ("Login[Argument]", oneIteration)
Business Process Testing (BPT)
This frameworks , breaks up large Business Processes into Components which can re-used multiple times in the same or different test scripts. For example , the Business Process of Booking a flight is split into components like Login , Finding Flights , Booking , Payment & Logout which can be re-used in the same Business process or different processes. Also, BPT facilitates closer coordination amongst SME's and Automation Engineers .
You Might Like
Advertise with UsAdvertise with Us Top 5 Things To Consider While Choosing a Test Management ToolTop 5 Things To Consider While Choosing a Test Management Tool TestLodge Tutorial for BeginnersTestLodge Tutorial for Beginners Top 20 Test Manager 



4.2. Using Optional and Named Arguments



Python allows function arguments to have default values; if the function is called without the argument, the argument
gets its default value. Futhermore, arguments can be specified in any order by using named arguments. Stored
procedures in SQL Server Transact/SQL can do this, so if you're a SQL Server scripting guru, you can skim this part.
Here is an example of info, a function with two optional arguments:
def info(object, spacing=10, collapse=1):
spacing and collapse are optional, because they have default values defined. object is required, because it has
no default value. If info is called with only one argument, spacing defaults to 10 and collapse defaults to 1. If
info is called with two arguments, collapse still defaults to 1.
Say you want to specify a value for collapse but want to accept the default value for spacing. In most
languages, you would be out of luck, because you would need to call the function with three arguments. But in
Python, arguments can be specified by name, in any order.

info(odbchelper)
info(odbchelper, 12)
info(odbchelper, collapse=0)
info(spacing=15, object=odbchelper)
With only one argument, spacing gets its default value of 10 and collapse gets its default value of
1.
With two arguments, collapse gets its default value of 1.

Here you are naming the collapse argument explicitly and specifying its value. spacing still gets its
default value of 10.
Even required arguments (like object, which has no default value) can be named, and named
arguments can appear in any order.
This looks totally whacked until you realize that arguments are simply a dictionary. The "normal" method of calling
functions without argument names is actually just a shorthand where Python matches up the values with the argument
names in the order they're specified in the function declaration. And most of the time, you'll call functions the
"normal" way, but you always have the additional flexibility if you need it.



4.3.1. The type Function


The type function returns the datatype of any arbitrary object. The possible types are listed in the types module.
This is useful for helper functions that can handle several types of data.
Example 4.5. Introducing type
>>> type(1)
<type 'int'>
>>> li = []
>>> type(li)
<type 'list'>
>>> import odbchelper
>>> type(odbchelper)
<type 'module'>
>>> import types
>>> type(odbchelper) == types.ModuleType
True
type takes anything ?? and I mean anything ?? and returns its datatype. Integers, strings, lists,
dictionaries, tuples, functions, classes, modules, even types are acceptable.
type can take a variable and return its datatype.
type also works on modules.
You can use the constants in the types module to compare types of objects. This is what the info
function does, as you'll see shortly.



Example 4.8. Introducing callable
>>> import string
>>> string.punctuation
'!"#$%&\'()*+,?./:;<=>?@[\\]^_`{|}~'
>>> string.join
<function join at 00C55A7C>
>>> callable(string.punctuation)
False
>>> callable(string.join)
True
>>> print string.join.__doc__
join(list [,sep]) ?> string
Return a string composed of the words in list, with
intervening occurrences of sep. The default separator is a
single space.
(joinfields and join are synonymous)
The functions in the string module are deprecated (although many people still use the join
function), but the module contains a lot of useful constants like this string.punctuation,
which contains all the standard punctuation characters.
string.join is a function that joins a list of strings.
string.punctuation is not callable; it is a string. (A string does have callable methods, but
the string itself is not callable.)
string.join is callable; it's a function that takes two arguments.
Any callable object may have a doc string. By using the callable function on each of an
object's attributes, you can determine which attributes you care about (methods, functions, classes)
and which you want to ignore (constants and so on) without knowing anything about the object
ahead of time.




4.6. The Peculiar Nature of and and or
In Python, and and or perform boolean logic as you would expect, but they do not return boolean values; instead,
they return one of the actual values they are comparing



>>> 'a' and 'b'
'b'
>>> 'a' or 'b'
'a'
>>>>>> '' and 'b'
''
>>> 'a' and 'b' and 'c'
'c'

>>> 'a' or 'b'
'a'
>>> '' or 'b'
'b'
>>> '' or [] or {}
{}
>>> def sidefx():
... print "in sidefx()"
... return 1
>>> 'a' or sidefx()
'a'


>>> a = "first"
>>> b = "second"
>>> 1 and a or b
'first'
>>> 0 and a or b
'second'


This syntax looks similar to the bool ? a : b expression in C. The entire expression is evaluated
from left to right, so the and is evaluated first. 1 and 'first' evalutes to 'first', then
'first' or 'second' evalutes to 'first'.
0 and 'first' evalutes to False, and then 0 or 'second' evaluates to 'second'.
However, since this Python expression is simply boolean logic, and not a special construct of the language, there is
one extremely important difference between this and?or trick in Python and the bool ? a : b syntax in C. If the
value of a is false, the expression will not work as you would expect it to. (Can you tell I was bitten by this? More
than once?)




Ways to list out the files with perticular extention:

1. Using OS.listdir

>>>
>>> for file in os.listdir("C:/automation/automationlib/scripts/input"):
...     if file.endswith(".txt"):
...             print file
...
fc_parameters.txt
interfaces.txt
interfaces_bkup.txt
nic_parameters.txt
QCC_update.txt
Tabs.txt
testCases.txt
wrong_parameters.txt

2. Using glob.glob:


>>> glob.glob("C:/automation/automationlib/scripts/input/*.txt")
['C:/automation/automationlib/scripts/input\\fc_parameters.txt', 'C:/automation/
automationlib/scripts/input\\interfaces.txt', 'C:/automation/automationlib/scrip
ts/input\\interfaces_bkup.txt', 'C:/automation/automationlib/scripts/input\\nic_
parameters.txt', 'C:/automation/automationlib/scripts/input\\QCC_update.txt', 'C
:/automation/automationlib/scripts/input\\Tabs.txt', 'C:/automation/automationli
b/scripts/input\\testCases.txt', 'C:/automation/automationlib/scripts/input\\wro
ng_parameters.txt']
>>>


3. Using OS.walk()





5.9. Private Functions
Like most languages, Python has the concept of private elements:
� Private functions, which can't be called from outside their module
� Private class methods, which can't be called from outside their class
� Private attributes, which can't be accessed from outside their class.
Unlike in most languages, whether a Python function, method, or attribute is private or public is determined entirely
by its name.
If the name of a Python function, class method, or attribute starts with (but doesn't end with) two underscores, it's
private; everything else is public. Python has no concept of protected class methods (accessible only in their own class
and descendant classes). Class methods are either private (accessible only in their own class) or public (accessible
from anywhere).
In MP3FileInfo, there are two methods: __parse and __setitem__. As you have already discussed,
__setitem__ is a special method; normally, you would call it indirectly by using the dictionary syntax on a class
instance, but it is public, and you could call it directly (even from outside the fileinfo module) if you had a really
good reason. However, __parse is private, because it has two underscores at the beginning of its name.
In Python, all special methods (like __setitem__) and built?in attributes (like __doc__) follow a standard
naming convention: they both start with and end with two underscores. Don't name your own methods and attributes
this way, because it will only confuse you (and others) later.
Example 5.19. Trying to Call a Private Method
>>> import fileinfo
>>> m = fileinfo.MP3FileInfo()
>>> m.__parse("/music/_singles/kairo.mp3")
Traceback (innermost last):
File "<interactive input>", line 1, in ?
AttributeError: 'MP3FileInfo' instance has no attribute '


If you try to call a private method, Python will raise a slightly misleading exception, saying that the method
does not exist. Of course it does exist, but it's private, so it's not accessible outside the class.Strictly speaking,
private methods are accessible outside their class, just not easily accessible. Nothing in Python is truly private;
internally, the names of private methods and attributes are mangled and unmangled on the fly to make them
seem inaccessible by their given names. You can access the __parse method of the MP3FileInfo class by


6.2. Working with File Objects

Python has a built?in function, open, for opening a file on disk. open returns a file object, which has methods and
attributes for getting information about and manipulating the opened file.
Example 6.3. Opening a File
>>> f = open("/music/_singles/kairo.mp3", "rb")
>>> f
<open file '/music/_singles/kairo.mp3', mode 'rb' at 010E3988>
>>> f.mode
'rb'
>>> f.name
'/music/_singles/kairo.mp3'
Dive


The open method can take up to three parameters: a filename, a mode, and a buffering parameter. Only the
first one, the filename, is required; the other two are optional. If not specified, the file is opened for reading in
text mode. Here you are opening the file for reading in binary mode. (print open.__doc__ displays a
great explanation of all the possible modes.)
The open function returns an object (by now, this should not surprise you). A file object has several useful
attributes.
The mode attribute of a file object tells you in which mode the file was opened.
The name attribute of a file object tells you the name of the file that the file object has open.


>>> f
<open file '/music/_singles/kairo.mp3', mode 'rb' at 010E3988>
>>> f.tell()
0
>>> f.seek(?128, 2)
>>> f.tell()
7542909
>>> tagData = f.read(128)
>>> tagData
'TAGKAIRO****THE BEST GOA ***DJ MARY?JANE***
Rave Mix 2000http://mp3.com/DJMARYJANE \037'
>>> f.tell()
7543037
A file object maintains state about the file it has open. The tell method of a file object tells you your
current position in the open file. Since you haven't done anything with this file yet, the current position is
0, which is the beginning of the file.
The seek method of a file object moves to another position in the open file. The second parameter
specifies what the first one means; 0 means move to an absolute position (counting from the start of the
file), 1 means move to a relative position (counting from the current position), and 2 means move to a
position relative to the end of the file. Since the MP3 tags you're looking for are stored at the end of the
file, you use 2 and tell the file object to move to a position 128 bytes from the end of the file.
The tell method confirms that the current file position has moved.
The read method reads a specified number of bytes from the open file and returns a string with the data
that was read. The optional parameter specifies the maximum number of bytes to read. If no parameter is
specified, read will read until the end of the file. (You could have simply said read() here, since you
know exactly where you are in the file and you are, in fact, reading the last 128 bytes.) The read data is
assigned to the tagData variable, and the current position is updated based on how many bytes were
read.
The tell method confirms that the current position has moved. If you do the math, you'll see that after
reading 128 bytes, the position has been incremented by 128.


Example 8.10. Introducing locals
>>> def foo(arg):
... x = 1
... print locals()
...
>>> foo(7)
{'arg': 7, 'x': 1}
>>> foo('bar')
{'arg': 'bar', 'x': 1}
The function foo has two variables in its local namespace: arg, whose value is passed in to the
function, and x, which is defined within the function.
locals returns a dictionary of name/value pairs. The keys of this dictionary are the names of the
variables as strings; the values of the dictionary are the actual values of the variables. So calling foo
with 7 prints the dictionary containing the function's two local variables: arg (7) and x (1).
Remember, Python has dynamic typing, so you could just as easily pass a string in for arg; the function
(and the call to locals) would still work just as well. locals works with all variables of all datatypes.
What locals does for the local (function) namespace, globals does for the global (module) namespace.
globals is more exciting, though, because a module's namespace is more exciting.[3] Not only does the module's
namespace include module?level variables and constants, it includes all the functions and classes defined in the
module. Plus, it includes anything that was imported into the module


for k, v in globals().items():
print k, "=", v
Just so you don't get intimidated, remember that you've seen all this before. The globals function returns a
dictionary, and you're iterating through the dictionary using the items method and multi?variable assignment.
The only thing new here is the globals function.


Example 8.12. locals is read?only, globals is not
def foo(arg):
x = 1
print locals()
locals()["x"] = 2
print "x=",x
z = 7
print "z=",z
foo(3)
globals()["z"] = 8
print "z=",z
Since foo is called with 3, this will print {'arg': 3, 'x': 1}. This should not be a surprise.
locals is a function that returns a dictionary, and here you are setting a value in that dictionary. You
might think that this would change the value of the local variable x to 2, but it doesn't. locals does not
actually return the local namespace, it returns a copy. So changing it does nothing to the value of thevariables in the local namespace.
This prints x= 1, not x= 2.
After being burned by locals, you might think that this wouldn't change the value of z, but it does.
Due to internal differences in how Python is implemented (which I'd rather not go into, since I don't fully
understand them myself), globals returns the actual global namespace, not a copy: the exact opposite
behavior of locals. So any changes to the dictionary returned by globals directly affect your global
variables.
This prints z= 8, not z= 7.



From the project:

 obj_cmd = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE)
        read_output = obj_cmd.stdout.read()
        return read_output


subprocess modules defines Popen class and others use this class

Note : We can also run the commands using OS.system()- if you want to run the command without interacting with it we use OS.system

shell= true

Setting the shell argument to true causes subprocess to spawn intermediate shell process and tell to run the command

Using intermediate shell means variables, glob pattern , other special shell features are processes before the command run



stdout=subprocess.PIPE- To run a process and read all of its output set the STDOUT value to PIPE



Questions of Druva:


1. How to find python version:

	>>> import sys
>>> print sys.version
2.5.5 (r255:77872, Jan 31 2010, 15:49:35) [MSC v.1310 32 bit (Intel)]
>>>


2. Can we write a class without __init__

-->
case 1:

>>>
>>> class test:
...     print "kailas"
...
kailas


Here we are not defing any functions , its working fine.


Case 2:


>>> class test:
...     def foo():
...             print "kakka"
...
>>> a=test()
>>> a.foo()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: foo() takes no arguments (1 given)


Here we are defining a function but it is throwing an error because we have not wrote "self" in function , though if we didnt define "__init__" we need to write self in function , bcos while calling that function , object gets passed.

correct code is here below:

Case 3 :


>>> class test:
...     def foo(self):
...             print "kailas"
...
>>> a=test()
>>> a.foo()
kailas
>>>






Example 6.10. Iterating Through a Dictionary
>>> import os
>>> for k, v in os.environ.items():
... print "%s=%s" % (k, v)
USERPROFILE=C:\Documents and Settings\mpilgrim
OS=Windows_NT
COMPUTERNAME=MPILGRIM
USERNAME=mpilgrim
[...snip...]
>>> print "\n".join(["%s=%s" % (k, v)
... for k, v in os.environ.items()])
USERPROFILE=C:\Documents and Settings\mpilgrim
OS=Windows_NT
COMPUTERNAME=MPILGRIM
USERNAME=mpilgrim
[...snip...]
os.environ is a dictionary of the environment variables defined on your system. In Windows, these are your
user and system variables accessible from MS?DOS. In UNIX, they are the variables exported in your shell's
startup scripts. In Mac OS, there is no concept of environment variables, so this dictionary is empty.
os.environ.items() returns a list of tuples: [(key1, value1), (key2, value2), ...]. The
for loop iterates through this list. The first round, it assigns key1 to k and value1 to v, so k =
USERPROFILE and v = C:\Documents and Settings\mpilgrim. In the second round, k gets the
second key, OS, and v gets the corresponding value, Windows_NT.
With multi?variable assignment and list comprehensions, you can replace the entire for loop with a single
statement. Whether you actually do this in real code is a matter of personal coding style. I like it because it
makes it clear that what I'm doing is mapping a dictionary into a list, then joining the list into a single string.
Other programmers prefer to write this out as a for loop. The output is the same in either case, although this
version is slightly faster, because there is only one print statement instead of many.
Now we can look at the for loop in MP3FileInfo, from the sample fileinfo.py program introduced




6.5. Working with Directories
The os.path module has several functions for manipulating files and directories. Here, we're looking at handling
pathnames and listing the contents of a directory.
Example 6.16. Constructing Pathnames
>>> import os
>>> os.path.join("c:\\music\\ap\\", "mahadeva.mp3")
'c:\\music\\ap\\mahadeva.mp3'
>>> os.path.join("c:\\music\\ap", "mahadeva.mp3")
'c:\\music\\ap\\mahadeva.mp3'
>>> os.path.expanduser("~")
'c:\\Documents and Settings\\mpilgrim\\My Documents'
>>> os.path.join(os.path.expanduser("~"), "Python")
'c:\\Documents and Settings\\mpilgrim\\My Documents\\Python'


>>> import os
>>> os.path.join("C:\Users\kbidve\Desktop\cli automation package", "fcautomation
_properties.txt")
'C:\\Users\\kbidve\\Desktop\\cli automation package\\fcautomation_properties.txt
'
>>>


os.path is a reference to a module ?? which module depends on your platform. Just as getpass
encapsulates differences between platforms by setting getpass to a platform?specific function, os
encapsulates differences between platforms by setting path to a platform?specific module

The join function of os.path constructs a pathname out of one or more partial pathnames. In this case, it
simply concatenates strings. (Note that dealing with pathnames on Windows is annoying because the backslash
character must be escaped.)
In this slightly less trivial case, join will add an extra backslash to the pathname before joining it to the
filename. I was overjoyed when I discovered this, since addSlashIfNecessary is one of the stupid little
functions I always need to write when building up my toolbox in a new language. Do not write this stupid little
function in Python; smart people have already taken care of it for you.
expanduser will expand a pathname that uses ~ to represent the current user's home directory. This works on
any platform where users have a home directory, like Windows, UNIX, and Mac OS X; it has no effect on Mac
OS.
Combining these techniques, you can easily construct pathnames for directories and files under the user's home
directory.



Example 6.17. Splitting Pathnames
>>> os.path.split("c:\\music\\ap\\mahadeva.mp3")
('c:\\music\\ap', 'mahadeva.mp3')
>>> (filepath, filename) = os.path.split("c:\\music\\ap\\mahadeva.mp3")
>>> filepath
'c:\\music\\ap'
>>> filename
'mahadeva.mp3'
>>> (shortname, extension) = os.path.splitext(filename)
>>> shortname
'mahadeva'
>>> extension
'.mp3'
The split function splits a full pathname and returns a tuple containing the path and filename. Remember
when I said you could use multi?variable assignment to return multiple values from a function? Well, split
is such a function.
You assign the return value of the split function into a tuple of two variables. Each variable receives the
value of the corresponding element of the returned tuple.
The first variable, filepath, receives the value of the first element of the tuple returned from split, the file
path.
The second variable, filename, receives the value of the second element of the tuple returned from split,
the filename.
os.path also contains a function splitext, which splits a filename and returns a tuple containing the
filename and the file extension. You use the same technique to assign each of them to separate variables.


>>> os.path.split("C:\Users\kbidve\Desktop\cli automation package\fcautomation_p
roperties.txt")
('C:\\Users\\kbidve\\Desktop', 'cli automation package\x0ccautomation_properties
.txt')
>>>



Example 6.18. Listing Directories
>>> os.listdir("c:\\music\\_singles\\")
['a_time_long_forgotten_con.mp3', 'hellraiser.mp3',
'kairo.mp3', 'long_way_home1.mp3', 'sidewinder.mp3',
'spinning.mp3']
>>> dirname = "c:\\"
>>> os.listdir(dirname)
['AUTOEXEC.BAT', 'boot.ini', 'CONFIG.SYS', 'cygwin',
'docbook', 'Documents and Settings', 'Incoming', 'Inetpub', 'IO.SYS',
'MSDOS.SYS', 'Music', 'NTDETECT.COM', 'ntldr', 'pagefile.sys',
'Program Files', 'Python20', 'RECYCLER',
'System Volume Information', 'TEMP', 'WINNT']
>>> [f for f in os.listdir(dirname)
... if os.path.isfile(os.path.join(dirname, f))]


['AUTOEXEC.BAT', 'boot.ini', 'CONFIG.SYS', 'IO.SYS', 'MSDOS.SYS',
'NTDETECT.COM', 'ntldr', 'pagefile.sys']
>>> [f for f in os.listdir(dirname)
... if os.path.isdir(os.path.join(dirname, f))]
['cygwin', 'docbook', 'Documents and Settings', 'Incoming',
'Inetpub', 'Music', 'Program Files', 'Python20', 'RECYCLER',
'System Volume Information', 'TEMP', 'WINNT']
The listdir function takes a pathname and returns a list of the contents of the directory.
listdir returns both files and folders, with no indication of which is which.
You can use list filtering and the isfile function of the os.path module to separate the files from
the folders. isfile takes a pathname and returns 1 if the path represents a file, and 0 otherwise. Here
you're using os.path.join to ensure a full pathname, but isfile also works with a partial path,
relative to the current working directory. You can use os.getcwd() to get the current working
directory.
os.path also has a isdir function which returns 1 if the path represents a directory, and 0
otherwise. You can use this to get a list of the subdirectories within a directory.



Example 6.19. Listing Directories in fileinfo.py


def listDirectory(directory, fileExtList):
"get list of file info objects for files of particular extensions"
fileList = [os.path.normcase(f)
for f in os.listdir(directory)]
fileList = [os.path.join(directory, f)
for f in fileList
if os.path.splitext(f)[1] in fileExtList]
os.listdir(directory) returns a list of all the files and folders in directory.
Iterating through the list with f, you use os.path.normcase(f) to normalize the case
according to operating system defaults. normcase is a useful little function that compensates
for case?insensitive operating systems that think that mahadeva.mp3 and mahadeva.MP3
are the same file. For instance, on Windows and Mac OS, normcase will convert the entire
filename to lowercase; on UNIX?compatible systems, it will return the filename unchanged.
Iterating through the normalized list with f again, you use os.path.splitext(f) to split
each filename into name and extension.
For each file, you see if the extension is in the list of file extensions you care about
(fileExtList, which was passed to the listDirectory function).
For each file you care about, you use os.path.join(directory, f) to construct the
full pathname of the file, and return a list of the full pathnames.
Whenever possible, you should use the functions in os and os.path for file, directory, and path manipulations.
These modules are wrappers for platform?specific modules, so functions like os.path.split work on UNIX,




ActivePython 2.5.5.7 (ActiveState Software Inc.) based on
Python 2.5.5 (r255:77872, Jan 31 2010, 15:49:35) [MSC v.1310 32 bit (Intel)] on
win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import os
>>> os.path.join("C:\Users\kbidve\Desktop\cli automation package\fcautomation_pr
operties.txt")
'C:\\Users\\kbidve\\Desktop\\cli automation package\x0ccautomation_properties.tx
t'
>>> os.path.splittext("C:\Users\kbidve\Desktop\cli automation package\fcautomati
on_properties.txt")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'splittext'
>>> os.path.splitext("C:\Users\kbidve\Desktop\cli automation package\fcautomatio
n_properties.txt")
('C:\\Users\\kbidve\\Desktop\\cli automation package\x0ccautomation_properties',
 '.txt')
>>>






